[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GEOSPATIAL ANALYTICS with R",
    "section": "",
    "text": "Content Disclaimer\n\n\n\n\n\nThis micro-site is intended as a personal portfolio based on what I have learned while pursuing my Master of IT in Business (Analytics) at Singapore Management University.\nOther than common facts or quotes from other parties, any views, opinions, or comments herein represented in this site are personal and belong solely to the site owner and do not represent those people, institutions or organisations that the owner may or may not be associated with professionally or within a personal capacity unless explicitly stated.\nThis site’s owner makes no representation of the accuracy or completeness of any display information or any link on this site. The owner will not be liable for any errors, omissions or availability of any information. The owner will not be liable for any of your losses, injuries, or damages from using the content within this site."
  },
  {
    "objectID": "ho/ho1_2.html",
    "href": "ho/ho1_2.html",
    "title": "Choropleth Mapping",
    "section": "",
    "text": "CREDIT\n\n\n\n\n\nOnce again, the credit for the code chunks and the key content of this post to Dr. Kam Tin Seong, my geospatial analytics lecturer at the School of Computing and Information Systems, Singapore Management University. He has helped me tremendously, from having zero knowledge and programming background to comfortably using R for geospatial analysis.\nAlso, credits for some examples and explanation to Uriel, my ChatGPT ( OpenAI ) buddy, named him after the Archangel of Wisdom :).\nThis post explores the functions in R to plot choropleth maps."
  },
  {
    "objectID": "ho/ho1_2.html#loading-r-packages",
    "href": "ho/ho1_2.html#loading-r-packages",
    "title": "Choropleth Mapping",
    "section": "1.1 Loading R Packages",
    "text": "1.1 Loading R Packages\nThe following are the packages required for the hands-on exercise :\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\np_load( ) - pacman - to load packages into R environment. This function will attempt to install the package from CRAN or the pacman repository list if it is not installed.\n\n\n\n\npacman::p_load(sf, tmap, tidyverse)"
  },
  {
    "objectID": "ho/ho1_2.html#data-importation",
    "href": "ho/ho1_2.html#data-importation",
    "title": "Choropleth Mapping",
    "section": "1.2 Data Importation",
    "text": "1.2 Data Importation\n\n1.2.1 Import Geospatial Data\nImport Singapore Urban Redevelopment Authority(URA) Master Plan 2014 Subzone Boundary from data.gov.sg into mpsz simple feature data frame -\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nst_read( ) - sf- to read the shapefile into simple features data frame format with 2 arguments below :\n\ndsn - define data path.\nlayer - provide shapefile name.\n\n\n\n\n\nmpsz = st_read(dsn = \"data/geospatial\",                \n               layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `D:\\jephOstan\\geospatial_jtz\\ho\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\n\n\n1.2.2 Import Aspatial Data\nImport Singapore Urban Redevelopment Authority(URA) Master Plan 2014 Subzone Boundary from data.gov.sg into mpsz simple feature data frame -\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nread_csv( ) - readr - to read a CSV file.\n\n\n\n\npopdata &lt;- read_csv(\"data/aspatial/respopagesextod2011to2020.csv\")"
  },
  {
    "objectID": "ho/ho1_2.html#data-inspection",
    "href": "ho/ho1_2.html#data-inspection",
    "title": "Choropleth Mapping",
    "section": "1.3 Data Inspection",
    "text": "1.3 Data Inspection\n\n1.3.1 Retrieve Information\n\nglimpse(popdata,60)\n\nRows: 984,656\nColumns: 7\n$ PA   &lt;chr&gt; \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", \"An…\n$ SZ   &lt;chr&gt; \"Ang Mo Kio Town Centre\", \"Ang Mo Kio Town Ce…\n$ AG   &lt;chr&gt; \"0_to_4\", \"0_to_4\", \"0_to_4\", \"0_to_4\", \"0_to…\n$ Sex  &lt;chr&gt; \"Males\", \"Males\", \"Males\", \"Males\", \"Males\", …\n$ TOD  &lt;chr&gt; \"HDB 1- and 2-Room Flats\", \"HDB 3-Room Flats\"…\n$ Pop  &lt;dbl&gt; 0, 10, 30, 50, 0, 0, 40, 0, 0, 10, 30, 60, 0,…\n$ Time &lt;dbl&gt; 2011, 2011, 2011, 2011, 2011, 2011, 2011, 201…"
  },
  {
    "objectID": "ho/ho1_2.html#data-wrangling",
    "href": "ho/ho1_2.html#data-wrangling",
    "title": "Choropleth Mapping",
    "section": "2.1 Data Wrangling",
    "text": "2.1 Data Wrangling\nFollowing are the additional variables will be needed for later choropleth plotting -\n\nYOUNG : age group 0 to 4 until age group 20 to 24.\nECONOMY ACTIVE : age group 25 - 29 until age group 60 - 64.\nAGED : age group 65 and above.\nTOTAL : all age groups.\nDEPENDENCY : the ratio between young & aged against the economy active group.\n\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\npivot_wider( ) - tidyr - to create new columns with column name based on AG & values based on pop.\nmutate( ) - dplyr - to create new columns as mentioned above.\nfilter( ) - dplyr - to keep only 2020 for Time attribute.\ngroup_ by( ) - dplyr - to group 3 variables - PA, SZ and AG.\nselect( ) - dplyr - to keep only variables that mentioned.\n\n\n\n\npopdata2020 &lt;- popdata %&gt;%\n  filter(Time == 2020) %&gt;%\n  group_by(PA, SZ, AG) %&gt;%\n  summarise(`POP` = sum(`Pop`)) %&gt;%\n  ungroup() %&gt;%\n  pivot_wider(names_from = AG, values_from = POP) %&gt;%\n  mutate(YOUNG = rowSums(.[3:6]) + rowSums(.[12])) %&gt;%\n  mutate(`ECONOMY ACTIVE` = rowSums(.[7:11]) + rowSums(.[13:15])) %&gt;% \n  mutate(`AGED` = rowSums(.[16:21])) %&gt;%\n  mutate(`TOTAL` = rowSums(.[3:21])) %&gt;%\n  mutate(`DEPENDENCY` = (`YOUNG` + `AGED`)/`ECONOMY ACTIVE`) %&gt;%\n  select(`PA`,`SZ`,`YOUNG`,`ECONOMY ACTIVE`,`AGED`,`TOTAL`,`DEPENDENCY`)"
  },
  {
    "objectID": "ho/ho1_2.html#merging-geospatial-aspatial-data",
    "href": "ho/ho1_2.html#merging-geospatial-aspatial-data",
    "title": "Choropleth Mapping",
    "section": "2.2 Merging Geospatial & Aspatial Data",
    "text": "2.2 Merging Geospatial & Aspatial Data\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nmutate_at( ) - dplyr - to modify specified columns PA and SZ in popdata2020.\n\n.fun argument to indicates the function, i.e. touper( ) applying on the specified columns. This function is to convert all text to uppercase in order to match the uppercase in the geospatial dataset.\n\nleft_join( ) - dplyr - to keep all observations in mpsz. This is an outer joins.\nwrite_rds( ) - readr - to serialise mpsz_pop2020. By default, no compression as space is cheaper than time.\n\n\n\n\npopdata2020 &lt;- popdata2020 %&gt;%\n  mutate_at(.vars = vars(PA, SZ),\n            .funs = list(toupper)) %&gt;%\n  filter(`ECONOMY ACTIVE` &gt; 0)\n\n\nmpsz_pop2020 &lt;- left_join(mpsz, popdata2020,\n                          by = c(\"SUBZONE_N\" = \"SZ\"))\n\n\nwrite_rds(mpsz_pop2020, \"data/mpszpop2020.rds\")"
  },
  {
    "objectID": "ho/ho1_2.html#mapping-with-tmap",
    "href": "ho/ho1_2.html#mapping-with-tmap",
    "title": "Choropleth Mapping",
    "section": "3.1 Mapping with tmap",
    "text": "3.1 Mapping with tmap\n\n3.1.1 Plot with qtm( )\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nqtm( ) - tmap - to plot a thematic map quickly. However, the aesthetic layers are\n\nfill - to specify which variable to be used for the choropleth. Set it NULL if just to draw the polygon borders.\n\n\n\n\n\nqtm(mpsz_pop2020,\n    fill = \"DEPENDENCY\")\n\n\n\n\n\nqtm(mpsz_pop2020,\n    fill = NULL)\n\n\n\n\n\n\n3.1.1 Plot Cartographic Furniture with tmap elements\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\ntm_shape( ) - tmap - to specify shape object, which in this case is mpsz_pop2020. This is to set the bounding box for the plot.\ntm_fill( ) - tmap - to specify which column’s value to be used for filling the polygons.\n\nplotting options for style argument :\n\nEach unique value will be a distinct category - cat\nDiscrete gradient options - fixed, sd, equal, pretty, quantile, kmeans, hclust, bclust, fisher, jenks, dpih, headtails\nContinuous gradient options - cont, order & log10\nLog scale - log10_pretty\n\nWhen the style is fixed, breaks argument should be specified.\ncolour options for palette argument : if not sure which palette to use, can input this code chunk at the console for references - tmaptools::palette_explorer()\n\ntm_layout( ) - tmap - to specify title, margins, aspect ratio, frame, legend, etc..\n\nframe by default is TRUE.\nframe.lwd specify the width of the frame.\nasp - if the aspect ratio is set to ‘0’, the ratio will be adjusted to the aspect ratio of the device.\n\ntm_borders( ) - tmap - to define the line colour, width, type for polygons’ borders.\n\ncol to indicate line colour.\nlwd to specify the line width.\nlty to specify the line type such as blank, dashed, dotted, dotdash, longdash, twodash, solid\nalpha to indicate the transparency level. Value between 0 (transparent) and 1 (not transparent). By default is 1.\n\ntm_compass( ) - tmap - to create compass.\n\nOptions available for type are arrow, 4star, 8star, radar, rose. By default is arrow.\n\ntm_scale_bar( ) - tmap - to create scale bar.\n\ncolor.dark - by default is set to black.\ncolor.light - by default is set to white.\n\ntm_grid( ) - tmap - to draw graticule lines.\n\n\n\n\nStyle : quantilesdequalkmeanshclustfisherheadtails\n\n\nNOTE : The default colour scheme is YlOrRd, missing value will be in grey and default interval binning based on pretty.\n\ntmap_mode(\"plot\")\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame.lwd = 5,\n            asp = 0) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type = \"8star\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha = 0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\nborder colour to white, number of classes, n to 10\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 10,\n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Test Elements\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame.lwd = 5,\n            asp = 0) +\n  tm_borders(alpha = 0.5, col = 'white') +\n  tm_compass(type = \"8star\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha = 0.2)\n\n\n\n\n\n\nApart from style changed to sd, palette to OrRd, borders to dashed, compass to arrow, and additional arguments for scale_bar.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"sd\", \n          palette = \"OrRd\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Test Elements\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame.lwd = 5,\n            asp = 0) +\n  tm_borders(alpha = 0.5, lty = 'dashed') +\n  tm_compass(type = \"arrow\", size = 2) +\n  tm_scale_bar(color.dark = 'red', color.light = 'orange') +\n  tm_grid(alpha = 0.2)\n\n\n\n\n\n\nStyle to equal, palette to Greys, borders to dotted and compass to radar .\nNOTE : be careful between Greys and grey - the output is entirely different!!!\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"equal\", \n          palette = \"Greys\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Test Elements\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame.lwd = 5,\n            asp = 0) +\n  tm_borders(alpha = 0.5, lty = 'dotted') +\n  tm_compass(type = \"radar\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha = 0.2)\n\n\n\n\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"equal\", \n          palette = \"grey\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Test Elements\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame.lwd = 5,\n            asp = 0) +\n  tm_borders(alpha = 0.5, lty = 'dotted') +\n  tm_compass(type = \"radar\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha = 0.2)\n\n\n\n\n\n\nStyle to kmeans , palette to YlOrRd, borders to longdash and compass to rose.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"kmeans\",\n          palette = \"YlOrRd\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Test Elements\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame.lwd = 5,\n            asp = 0) +\n  tm_borders(alpha = 0.5, lty = 'longdash') +\n  tm_compass(type = \"rose\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha = 0.2)\n\n\n\n\n\n\nStyle to hclust and border to blank, and test default without palette argument.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"hclust\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Test Elements\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame.lwd = 5,\n            asp = 0) +\n  tm_borders(alpha = 0.5, lty = 'blank') +\n  tm_compass(type = \"rose\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha = 0.2)\n\n\n\n\n\n\nStyle to fisher. The output same as jenks\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"fisher\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Test Elements\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame.lwd = 5,\n            asp = 0) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type = \"rose\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha = 0.2)\n\n\n\n\n\n\nStyle to headtails.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"headtails\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Test Elements\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame.lwd = 5,\n            asp = 0) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type = \"rose\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha = 0.2)\n\n\n\n\n\n\n\n\n\n3.1.2 Binning Customisation\n\nsummary(mpsz_pop2020$DEPENDENCY)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.1111  0.7147  0.7866  0.8585  0.8763 19.0000      92 \n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          breaks = c(0, 0.60, 0.70, 0.80, 0.90, 19.0)) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n3.1.3 Colour Reversion\nWhen the context requires to highlight smaller values, add a ‘-’ prefix.\n\nHighlight High ValuesLow Values\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"Greens\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\n\n\n3.1.4 Additional Elements Map Layout\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"jenks\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone \\n(Jenks classification)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            legend.outside = FALSE,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n3.1.5 Map Style\nNote that element is not referring to the style argument under tm_fill.\n\nClassicGrayNaturalCobaltCol_blindAlbatrossBeaverBWWatercolor\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"classic\")\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"gray\")\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"natural\")\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"cobalt\")\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"col_blind\")\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"albatross\")\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"beaver\")\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"bw\")\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"watercolor\")\n\n\n\n\n\n\n\nTo reset the default style -\n\ntmap_style(\"white\")\n\n\n\n3.2.1 Facet Choropleth Maps\nThere are 3 ways to plot -\n\nmultiple values to at least one of the asthetic arguments;\ndefine a group-by variable in tm_facets( );\ncreate multiple stand-alone maps with tmap_arrange( ).\n\n\n3.2.1.1 Multiple values in tm_fill( )\n\nPalette : Same ColourDifferent Colours\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(c(\"YOUNG\", \"AGED\"),\n          style = \"equal\", \n          palette = \"Blues\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\")) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+ \n  tm_polygons(c(\"DEPENDENCY\",\"AGED\"),\n          style = c(\"equal\", \"quantile\"), \n          palette = list(\"Blues\",\"Greens\")) +\n  tm_layout(legend.position = c(\"right\", \"bottom\"))\n\n\n\n\n\n\n\n\n\n3.2.1.2 Withtm_facets( )\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\ntm_facets( ) - tmap - to plot multiple small choropleth maps.\n\nfree.coords - works along with by argument. By default is TRUE, alphabetically?\ndrop.units - By default TRUE. When FALSE, they are plotted where mapped aesthetics are regarded as missing values.\n\n\n\n\n\nDROP.UNITS : TRUEFALSE\n\n\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"Blues\",\n          thres.poly = 0) + \n  tm_facets(by = \"REGION_N\", \n            free.coords = TRUE, \n            drop.units = TRUE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c(\"center\", \"center\"), \n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"Blues\",\n          thres.poly = 0) + \n  tm_facets(by = \"REGION_N\", \n            free.coords = TRUE, \n            drop.units = FALSE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c(\"center\", \"center\"), \n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\n\n\n3.2.1.3 Withtmap_arrange( )\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\ntmap_arrange( ) - tmap - to arrange multiple stand-alone maps in grid layout.\n\nsync - navigation in view mode (zooming and panning) be synchronised. By default is FALSE.\n\n\n\n\n\nyoungmap &lt;- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"YOUNG\", \n              n = 4,\n              style = \"quantile\", \n              palette = \"Blues\") +\n  tm_layout(legend.height = 0.42, \n            legend.width = 0.38,\n            frame.lwd = 3)\n\nagedmap &lt;- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"AGED\",\n              n = 4,\n              style = \"quantile\", \n              palette = \"Blues\") +\n  tm_layout(legend.height = 0.42, \n            legend.width = 0.38,\n            frame.lwd = 3)\n\neconactmap &lt;- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"ECONOMY ACTIVE\",\n              n = 4,\n              style = \"quantile\", \n              palette = \"Blues\") +\n  tm_layout(legend.height = 0.42, \n            legend.width = 0.38,\n            frame.lwd = 3)\n\ntmap_arrange(youngmap, agedmap, econactmap, \n             heights = 1, widths = 1, asp = 2, ncol = 2, nrow = 2, sync = TRUE)\n\n\n\n\n\n\n\n3.2.2 Mapping specific Spatial Object for Specific Purposes\nNOTE : When tmap_mode set to view, the histogram will not be able to display correctly. So this function cannot be used along with legend.hist.\n\nNON-INTERACTIVEINTERACTIVE\n\n\n\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N == \"CENTRAL REGION\",]) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\", \n          palette = \"-Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 1) +\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.8, \n            legend.width = 5.0,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5, col = 'white')\n\n\n\n\n\n\n\ntmap_mode(\"view\")\ntmap_options(check.and.fix = TRUE)\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N == \"CENTRAL REGION\",]) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\", \n          palette = \"-Blues\") +\n  tm_view(set.zoom.limits = c(12, 15)) +\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.6, \n            legend.width = 5.0) +\n  tm_borders(alpha = 0.68, col = 'white')"
  },
  {
    "objectID": "ho/data/geospatial/MPSZ-2019.html",
    "href": "ho/data/geospatial/MPSZ-2019.html",
    "title": "Geospatial Analytics",
    "section": "",
    "text": "&lt;!DOCTYPE qgis PUBLIC ‘http://mrcc.com/qgis.dtd’ ‘SYSTEM’&gt;     dataset\n\n\n        0 0     false"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Profile",
    "section": "",
    "text": "Name : Joseph Zexeong Tan\nResidency : Singapore Permanent Resident\nLanguage Proficiency : English, Mandarin, Malay, Dialect-Cantonese, Dialect-Hokkien, French (elementary).\nInterests : Volunteering to clean up Pulau Ubin, endurance-multi-sports (swim, cycle, run) workout.\nAwards : 2nd runner up in both Sudoku tournaments (2007, 2008) when pursuing my undergrad degree at UMS."
  },
  {
    "objectID": "about.html#working-experiences",
    "href": "about.html#working-experiences",
    "title": "Profile",
    "section": "WORKING EXPERIENCES",
    "text": "WORKING EXPERIENCES\n\nSoftware Solutions Consultancy\n\nproject management, quality assurance, UI/UX design, digital marketing, account supports, business development, end-user trainer\n\n\n\nEnvironmental Consultancy\n\nenvironmental impact assessment (EIA) consultant\n\n\n\nWall & Glass Decal & Retail\n\noperational management, designer, installer\n\n\n\nFood & Beverages\n\noperational management, business co-owner"
  },
  {
    "objectID": "ho/ho1_1.html",
    "href": "ho/ho1_1.html",
    "title": "Data Wrangling with R",
    "section": "",
    "text": "CREDIT\n\n\n\n\n\nOnce again, the credit for the code chunks and the key content of this post to Dr. Kam Tin Seong, my geospatial analytics lecturer at the School of Computing and Information Systems, Singapore Management University. He has helped me tremendously, from having zero knowledge and programming background to comfortably using R for geospatial analysis.\nAlso, credits for some examples and explanation to Uriel, my ChatGPT ( OpenAI ) buddy, named him after the Archangel of Wisdom :).\nThis post covers the basic wrangling technique for geospatial data such as -"
  },
  {
    "objectID": "ho/ho1_1.html#loading-r-packages",
    "href": "ho/ho1_1.html#loading-r-packages",
    "title": "Data Wrangling with R",
    "section": "1.1 Loading R Packages",
    "text": "1.1 Loading R Packages\nThe following are the packages required for the hands-on exercise :\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\np_load( ) - pacman - to load packages into R environment. This function will attempt to install the package from CRAN or the pacman repository list if it is not installed.\n\n\n\n\npacman::p_load(sf, tidyverse)"
  },
  {
    "objectID": "ho/ho1_1.html#data-importation",
    "href": "ho/ho1_1.html#data-importation",
    "title": "Data Wrangling with R",
    "section": "1.2 Data Importation",
    "text": "1.2 Data Importation\n\n1.2.1 Import Geospatial Data\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nst_read( ) - sf- to read the shapefile into simple features data frame format with 2 arguments below :\n\ndsn - define data path.\nlayer - provide shapefile name.\n\n\n\n\n\n1.2.1.1 Polygon feature data in shapefile format\nImport Singapore Master Plan 2014 Subzone Boundary from data.gov.sg into mpsz simple feature data frame -\n\nmpsz = st_read(dsn = \"data/geospatial\",\n               layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `D:\\jephOstan\\geospatial_jtz\\ho\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\nMetrics used in the output above -\n\nGeometry type : Refers to the type of shapes represented in the spatial data.\nDimension : “XY” means that the geometries are defined in a two-dimensional space with an X (longitude) and a Y (latitude) coordinate.\nBounding Box : The bounding box represents the extent of the spatial dataset, defined by the minimum and maximum coordinates in each dimension.\n\n“xmin”, “ymin”, “xmax”, and “ymax” represent the minimum longitude, minimum latitude, maximum longitude, and maximum latitude, respectively.\n\nProjected CRS : Coordinate Reference System (CRS) is a system that uses one or more numbers or coordinates to determine the position of a point or a geometric element uniquely.\nSVY21 is a specific type of CRS, which stands for the Singapore Transverse Mercator projection, used for creating maps and conducting land surveys in Singapore.\n\n\n\n1.2.1.2 Polyline feature data in shapefile format\nImport cycling path from LTADataMall.\n\ncyclingPath = st_read(dsn = \"data/geospatial\",\n                      layer = \"CyclingPath\")\n\nReading layer `CyclingPath' from data source \n  `D:\\jephOstan\\geospatial_jtz\\ho\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 2248 features and 2 fields\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: 11854.32 ymin: 28347.98 xmax: 42626.09 ymax: 48948.15\nProjected CRS: SVY21\n\n\n\n\n1.2.1.3 GIS data in kml format\n\npreschool = st_read(\"data/geospatial/pre-schools-location-kml.kml\")\n\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `D:\\jephOstan\\geospatial_jtz\\ho\\data\\geospatial\\pre-schools-location-kml.kml' \n  using driver `KML'\nSimple feature collection with 1925 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.247759 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n\n\nUnlike SVY21 for other dataset, this preschool dataset is WGS 84 - which stands for World Geodetic System 1984 - a global reference coordinate system used by the Global Positioning System (GPS).\n\n\n\n1.2.2 Import Aspatial Data\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nread_csv( ) - readr - to read a CSV file.\n\n\n\n\nlistings &lt;- read_csv(\"data/aspatial/listings.csv\")"
  },
  {
    "objectID": "ho/ho1_1.html#data-inspection",
    "href": "ho/ho1_1.html#data-inspection",
    "title": "Data Wrangling with R",
    "section": "1.3 Data Inspection",
    "text": "1.3 Data Inspection\n\n1.3.1 Retrieve Information\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nst_geometry( ) - sf- to get geometry information from an sf object.\n\n\n\n\nst_geometry(mpsz)\n\nGeometry set for 323 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 5 geometries:\n\n\nWith “mpsz$geom” or specifically indiate the position of the geometry column, “mpsz[[1]]” can also produced the same output as shown above.\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nglimpse( ) - dplyr- to reveals the data type of each feature / variable. Specify an integer behind to reveal the amount of information to be displayed.\n\ndbl shorts for “Double-precision” value.\n\n\n\n\n\nglimpse(mpsz,60)\n\nRows: 323\nColumns: 16\n$ OBJECTID   &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, …\n$ SUBZONE_NO &lt;int&gt; 1, 1, 3, 8, 3, 7, 9, 2, 13, 7, 12, 6, 1…\n$ SUBZONE_N  &lt;chr&gt; \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT Q…\n$ SUBZONE_C  &lt;chr&gt; \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\",…\n$ CA_IND     &lt;chr&gt; \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"Y\",…\n$ PLN_AREA_N &lt;chr&gt; \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RI…\n$ PLN_AREA_C &lt;chr&gt; \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\", \"BM…\n$ REGION_N   &lt;chr&gt; \"CENTRAL REGION\", \"CENTRAL REGION\", \"CE…\n$ REGION_C   &lt;chr&gt; \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR…\n$ INC_CRC    &lt;chr&gt; \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\",…\n$ FMEL_UPD_D &lt;date&gt; 2014-12-05, 2014-12-05, 2014-12-05, 20…\n$ X_ADDR     &lt;dbl&gt; 31595.84, 28679.06, 29654.96, 26782.83,…\n$ Y_ADDR     &lt;dbl&gt; 29220.19, 29782.05, 29974.66, 29933.77,…\n$ SHAPE_Leng &lt;dbl&gt; 5267.381, 3506.107, 1740.926, 3313.625,…\n$ SHAPE_Area &lt;dbl&gt; 1630379.3, 559816.2, 160807.5, 595428.9…\n$ geometry   &lt;MULTIPOLYGON [m]&gt; MULTIPOLYGON (((31495.56 3…\n\n\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nhead( ) - utils - to return the top n features of mpsz. If n is not specified, top 6 (default) features will be displayed instead. Directly specified the integer works as well.\n\n\n\n\nhead(mpsz, n = 2)\n\nSimple feature collection with 2 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 28160.23 ymin: 28369.47 xmax: 32362.39 ymax: 30177.73\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO    SUBZONE_N SUBZONE_C CA_IND   PLN_AREA_N PLN_AREA_C\n1        1          1 MARINA SOUTH    MSSZ01      Y MARINA SOUTH         MS\n2        2          1 PEARL'S HILL    OTSZ01      Y       OUTRAM         OT\n        REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR\n1 CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84 29220.19\n2 CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06 29782.05\n  SHAPE_Leng SHAPE_Area                       geometry\n1   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n\n\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nlist( ) - base - to create a tibble data frame that contain all different types of variables in &lt;listings&gt;.\n\n\n\n\nlist(listings)\n\n[[1]]\n# A tibble: 4,161 × 18\n       id name      host_id host_name neighbourhood_group neighbourhood latitude\n    &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;               &lt;chr&gt;            &lt;dbl&gt;\n 1  50646 Pleasant…  227796 Sujatha   Central Region      Bukit Timah       1.33\n 2  71609 Ensuite …  367042 Belinda   East Region         Tampines          1.35\n 3  71896 B&B  Roo…  367042 Belinda   East Region         Tampines          1.35\n 4  71903 Room 2-n…  367042 Belinda   East Region         Tampines          1.35\n 5 275344 15 mins … 1439258 Kay       Central Region      Bukit Merah       1.29\n 6 289234 Booking …  367042 Belinda   East Region         Tampines          1.34\n 7 294281 5 mins w… 1521514 Elizabeth Central Region      Newton            1.31\n 8 324945 Cozy Blu… 1439258 Kay       Central Region      Bukit Merah       1.29\n 9 330089 Cozy Blu… 1439258 Kay       Central Region      Bukit Merah       1.29\n10 330095 10 mins … 1439258 Kay       Central Region      Bukit Merah       1.29\n# ℹ 4,151 more rows\n# ℹ 11 more variables: longitude &lt;dbl&gt;, room_type &lt;chr&gt;, price &lt;dbl&gt;,\n#   minimum_nights &lt;dbl&gt;, number_of_reviews &lt;dbl&gt;, last_review &lt;date&gt;,\n#   reviews_per_month &lt;dbl&gt;, calculated_host_listings_count &lt;dbl&gt;,\n#   availability_365 &lt;dbl&gt;, number_of_reviews_ltm &lt;dbl&gt;, license &lt;chr&gt;\n\n\nFrom the output above, latitude and longitude are in decimal degree format, which best assumes it’s in wgs84 Geographic Coordinate System."
  },
  {
    "objectID": "ho/ho1_1.html#data-visualisation",
    "href": "ho/ho1_1.html#data-visualisation",
    "title": "Data Wrangling with R",
    "section": "1.4 Data Visualisation",
    "text": "1.4 Data Visualisation\n\n1.4.1 Retrieve Information\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nplot( ) - graphics - to visualise geospatial features.\n\n\n\n\nplot(mpsz)\n\n\n\n\nPlot only the boundaries - combine both plot( ) together with st_geometry( ) to specifically get the geometry details for plot( ) to plot.\n\nplot(st_geometry(mpsz))\n\n\n\n\nor, specifically indicate which attribute / variable to plot.\n\nplot(mpsz[\"PLN_AREA_N\"])"
  },
  {
    "objectID": "ho/ho1_1.html#projection-transformation",
    "href": "ho/ho1_1.html#projection-transformation",
    "title": "Data Wrangling with R",
    "section": "2.1 Projection Transformation",
    "text": "2.1 Projection Transformation\n\n2.1.1 Inspect & Edit the EPSG Code\n2 common issues encountered when importing geospatial data -\n\nShapefile with missing .proj file.\nThe projected CRS is wrongly assigned.\n\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nst_crs( ) - sf - to retrieve coordinate reference system for mpsz.\n\n\n\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\nThe EPSG code for “svy21” should be 3414, not 9001 as shown above.\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nst_set_crs( ) - sf - to replace the coordinate reference system for mpsz.\n\n\n\n\nmpsz3414 &lt;- st_set_crs(mpsz, 3414)\n\n\n\n2.1.2 Transform Geographic Coordinate System to Projected CRS\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nst_transform( ) - sf - to reproject x from one coordinate system wgs84 to svy21 mathematically, which is not capable by st_set_crs( ).\n\n\n\n\npreschool3414 &lt;- st_transform(preschool, \n                              crs = 3414)"
  },
  {
    "objectID": "ho/ho1_1.html#aspatial-data-frame-transformation",
    "href": "ho/ho1_1.html#aspatial-data-frame-transformation",
    "title": "Data Wrangling with R",
    "section": "2.2 Aspatial Data Frame Transformation",
    "text": "2.2 Aspatial Data Frame Transformation\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nst_as_sf( ) - sf - to convert aspatial object, i.e., listings to an sf object.\n\ncoords - provide x-coordinates first before y-coordinates.\ncrs - define the coordinates reference system with EPSG : 4326 ( wgs84 Geographic Coordinate System)\n%&gt;% - to nest st_transform( ) to transform the newly created simple feature data frame into EPSG : 3414 which is Singapore’s SVY21 projected CRS.\n\n\n\n\n\nlistings_sf &lt;- st_as_sf(listings,\n                        coords = c(\"longitude\", \"latitude\"),\n                        crs = 4326) %&gt;%\n  st_transform(crs = 3414)\n\n\nglimpse(listings_sf, 70)\n\nRows: 4,161\nColumns: 17\n$ id                             &lt;dbl&gt; 50646, 71609, 71896, 71903, 2…\n$ name                           &lt;chr&gt; \"Pleasant Room along Bukit Ti…\n$ host_id                        &lt;dbl&gt; 227796, 367042, 367042, 36704…\n$ host_name                      &lt;chr&gt; \"Sujatha\", \"Belinda\", \"Belind…\n$ neighbourhood_group            &lt;chr&gt; \"Central Region\", \"East Regio…\n$ neighbourhood                  &lt;chr&gt; \"Bukit Timah\", \"Tampines\", \"T…\n$ room_type                      &lt;chr&gt; \"Private room\", \"Private room…\n$ price                          &lt;dbl&gt; 80, 145, 85, 85, 49, 184, 79,…\n$ minimum_nights                 &lt;dbl&gt; 92, 92, 92, 92, 60, 92, 92, 6…\n$ number_of_reviews              &lt;dbl&gt; 18, 20, 24, 47, 14, 12, 133, …\n$ last_review                    &lt;date&gt; 2014-12-26, 2020-01-17, 2019…\n$ reviews_per_month              &lt;dbl&gt; 0.18, 0.15, 0.18, 0.34, 0.11,…\n$ calculated_host_listings_count &lt;dbl&gt; 1, 6, 6, 6, 44, 6, 7, 44, 44,…\n$ availability_365               &lt;dbl&gt; 365, 340, 265, 365, 296, 285,…\n$ number_of_reviews_ltm          &lt;dbl&gt; 0, 0, 0, 0, 1, 0, 0, 3, 2, 0,…\n$ license                        &lt;chr&gt; NA, NA, NA, NA, \"S0399\", NA, …\n$ geometry                       &lt;POINT [m]&gt; POINT (22646.02 35167.9…\n\n\nA new column, geometry is introduced while longitude & latitude are dropped from the data frame."
  },
  {
    "objectID": "ho/ho1_1.html#buffering",
    "href": "ho/ho1_1.html#buffering",
    "title": "Data Wrangling with R",
    "section": "3.1 Buffering",
    "text": "3.1 Buffering\nBuffering is a GIS technique to define an area bidirectional or setback of distance or width from a geographic feature (point, line or polygon).\nBelow are some of use cases for this GIS technique -\n\nEcological Studies: Determining impact zones around protected wildlife areas to analyse potential effects of human activities on habitats.\nUrban Planning: Establishing zones around public facilities like schools or hospitals to evaluate accessibility for nearby residents.\nTransportation Engineering: Assessing areas within a certain radius of public transit lines to optimise service coverage and planning.\nEmergency Preparedness: Creating zones around industrial plants to simulate the extent of potential chemical spills for evacuation planning.\nMarket Analysis: Defining catchment areas around retail stores to understand the demographic profile of potential customers living within a specific distance.\nEnvironmental Protection: Designating buffer zones around rivers or lakes to protect water quality from adjacent land-use activities.\nRisk Assessment: Evaluating flood risk by creating buffers along waterways that might overflow, affecting adjacent areas.\nAgricultural Management: Determining pesticide-free zones around crop fields by buffering from schools or residential areas.\nPublic Safety: Analysing crime incidence by creating buffers around areas of interest, such as nightlife districts, to allocate police resources effectively.\nTelecommunications: Planning network infrastructure by buffering around existing cell towers to identify areas with weak signal coverage for improvement.\n\n\n3.1.1 Create buffer distance\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nst_buffer( ) - sf - to set geometric unary operation.\n\ndist - to set 5 metre buffer distance for cyclingpath.\nnQuadSegs - to set number of segments per quadrant.\n\n\n\n\n\nbuffer_cycling &lt;- st_buffer(cyclingPath, \n                            dist = 5, \n                            nQuadSegs = 30)\n\n\n\n3.1.2 Calculate buffer / area\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nst_area( ) - sf - to compute the buffered area in buffer_cycling . The area is introduced under a new attribute area.\nnote - if st_area on cyclingPath will have 0 m2 for area.\n\n\n\n\nbuffer_cycling$area &lt;- st_area(buffer_cycling)\n\n\nsum(buffer_cycling$area)\n\n1556978 [m^2]"
  },
  {
    "objectID": "ho/ho1_1.html#point-in-polygon-pip-count",
    "href": "ho/ho1_1.html#point-in-polygon-pip-count",
    "title": "Data Wrangling with R",
    "section": "3.2 Point-in-Polygon (PIP) Count",
    "text": "3.2 Point-in-Polygon (PIP) Count\nThis GIS technique is used to determine how many point features (such as locations of schools, hospitals, or crime incidents) fall within polygon features (like municipal boundaries, neighborhoods, or zones).\nThis technique is very useful for understanding the distribution and concentration of features across a geographic area and can inform policy decisions, resource allocation, or identify trends and patterns in spatial data.\n\n3.2.1 Intersection & calculate\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nst_intersects( ) - sf - to identify pre-schools located inside each Planning Subzone.\nlength( ) - base - to aggregate and count the intersection points within each Planning Subzone.\n\n\n\n\nmpsz3414$`PreSch Count`&lt;- lengths(st_intersects(mpsz3414, preschool3414))\n\n\nsummary(mpsz3414$`PreSch Count`)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00    0.00    3.00    5.96    9.00   58.00 \n\n\n\n\n3.2.2 Sort listing\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\ntop_n( x , n, wt) - dplyr - to list the Planning Subzone with the most pre-schools.\n\nx - a data frame, in this case, mpsz3414\nn - number of rows returned.\nwt - the variable for the sorting. If not specified, the last column will be used by default.\n\n\n\n\n\ntop_n(mpsz3414, 3, `PreSch Count`)\n\nSimple feature collection with 3 features and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 23449.05 ymin: 33973.71 xmax: 42940.57 ymax: 47996.47\nProjected CRS: SVY21 / Singapore TM\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n1      189          2  TAMPINES EAST    TMSZ02      N   TAMPINES         TM\n2      199          4    BEDOK NORTH    BDSZ04      N      BEDOK         BD\n3      290          3 WOODLANDS EAST    WDSZ03      N  WOODLANDS         WD\n      REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR\n1  EAST REGION       ER 21658EAAF84F4D8D 2014-12-05 41122.55 37392.39\n2  EAST REGION       ER A2254301F85C1EDF 2014-12-05 39429.21 34737.62\n3 NORTH REGION       NR C90769E43EE6B0F2 2014-12-05 24506.64 46991.63\n  SHAPE_Leng SHAPE_Area                       geometry PreSch Count\n1  10180.624    4339824 MULTIPOLYGON (((42196.76 38...           58\n2   8414.962    3203663 MULTIPOLYGON (((40284.24 35...           31\n3   6603.608    2553464 MULTIPOLYGON (((24786.75 46...           47\n\n\n\n\n3.2.3 Compute density\nFirst step is to derive the area of each Planning Subzone under mpsz3414.\n\nmpsz3414$Area &lt;- mpsz3414 %&gt;%\n  st_area()\n\nSecond step is to compute the density with the mutate function.\n\nmpsz3414 &lt;- mpsz3414 %&gt;%\n  mutate(`PreSch Density` = `PreSch Count` / Area * 1000000)"
  },
  {
    "objectID": "ho/ho1_1.html#histogram",
    "href": "ho/ho1_1.html#histogram",
    "title": "Data Wrangling with R",
    "section": "4.1 Histogram",
    "text": "4.1 Histogram\nFor quick assessment or non-publication usage -\n\nhist(mpsz3414$`PreSch Density`)\n\n\n\n\nFor a more fine-tuned / customised histogram -\n\nggplot(data = mpsz3414, \n       aes(x = as.numeric(`PreSch Density`))) +\n  geom_histogram(bins = 20, \n                 color = \"white\", \n                 fill = \"salmon\") +\n  labs(title = \"DISTRIBUTION OF PRE-SCHOOL DENSITY ACROSS SGP PLANNING SUBZONES\",\n       subtitle = \"The histogram illustrates a right-skewed distribution of pre-school density per square kilometre across Planning Subzones. \\nThe tail of the distribution extends to the right, indicating outliers or exceptional Subzones \\nwith preschool densities considerably above the norm.\",\n       x = \"Pre-school Density (per km sq)\",\n       y = \"Frequency\") +\n  theme(plot.title = element_text (size = 14, \n                                   colour = \"#302f2f\",\n                                   face = \"bold\"),\n        plot.subtitle = element_text(size = 9.5,\n                                     colour = \"#424242\",\n                                     face = \"italic\"))"
  },
  {
    "objectID": "ho/ho1_1.html#scatterplot",
    "href": "ho/ho1_1.html#scatterplot",
    "title": "Data Wrangling with R",
    "section": "4.2 Scatterplot",
    "text": "4.2 Scatterplot\nShow relationship between Pre-school Density and Pre-school Count.\n\nggplot(data = mpsz3414, \n       aes(y = `PreSch Count`, \n           x = as.numeric(`PreSch Density`))) +\n  geom_point(color = \"black\", \n             fill = \"salmon\") +\n  xlim(0, 40) +\n  ylim(0, 40) +\n  labs(title = \"SPATIAL DISTRIBUTION OF SINGAPORE PRE-SCHOOL FACILITIES\",\n       subtitle = \"Correlation Between Pre-School Count and Density per Square Kilometer Across Subzones\",\n       x = \"Pre-school density (per km sq)\",\n       y = \"Pre-school count\") +\n  theme(plot.title = element_text (size = 14, \n                                   colour = \"#302f2f\",\n                                   face = \"bold\"),\n        plot.subtitle = element_text(size = 11,\n                                     colour = \"#424242\",\n                                     face = \"italic\"))"
  },
  {
    "objectID": "ho/ho2_1.html",
    "href": "ho/ho2_1.html",
    "title": "1st Order Methods",
    "section": "",
    "text": "CREDIT\n\n\n\n\n\nOnce again, the credit for the code chunks and the key content of this post to Dr. Kam Tin Seong, my geospatial analytics lecturer at the School of Computing and Information Systems, Singapore Management University. He has helped me tremendously, from having zero knowledge and programming background to comfortably using R for geospatial analysis.\nAlso, credits for some examples and explanation to Uriel, my ChatGPT ( OpenAI ) buddy, named him after the Archangel of Wisdom :)\nSpatial Point Pattern Analysis (SPPA) is a branch of spatial statistics that focuses on analysing patterns formed by points in space. This analysis is typically divided into first-order and second-order characteristics.\nThis post is exploring the first-order to address the following questions -"
  },
  {
    "objectID": "ho/ho2_1.html#loading-r-packages",
    "href": "ho/ho2_1.html#loading-r-packages",
    "title": "1st Order Methods",
    "section": "1.1 Loading R Packages",
    "text": "1.1 Loading R Packages\nThe following are the packages required for the hands-on exercise :\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\np_load( ) - pacman - to load packages into R environment. This function will attempt to install the package from CRAN or the pacman repository list if it is not installed.\n\n\n\n\npacman::p_load(maptools, sf, raster, spatstat, tmap, tidyverse)"
  },
  {
    "objectID": "ho/ho2_1.html#data-importation",
    "href": "ho/ho2_1.html#data-importation",
    "title": "1st Order Methods",
    "section": "1.2 Data Importation",
    "text": "1.2 Data Importation\n\n1.2.1 Import Geospatial Data\nThe data set for childcare centres are obtained from Data.gov.sg is a point feature data.\n\nchildcare_sf &lt;- st_read(\"data/geospatial/PreSchoolsLocation.geojson\") %&gt;%\n  st_transform(crs = 3414)\n\nReading layer `PreSchoolsLocation' from data source \n  `D:\\jephOstan\\geospatial_jtz\\ho\\data\\geospatial\\PreSchoolsLocation.geojson' \n  using driver `GeoJSON'\nSimple feature collection with 2290 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6878 ymin: 1.247759 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n\n\n\nsg_sf &lt;- st_read(dsn = \"data/geospatial\", \n                 layer = \"CostalOutline\")\n\nReading layer `CostalOutline' from data source \n  `D:\\jephOstan\\geospatial_jtz\\ho\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 60 features and 4 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2663.926 ymin: 16357.98 xmax: 56047.79 ymax: 50244.03\nProjected CRS: SVY21\n\n\n\nmpsz_sf = st_read(dsn = \"data/geospatial\",                                \n                  layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `D:\\jephOstan\\geospatial_jtz\\ho\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21"
  },
  {
    "objectID": "ho/ho2_1.html#data-inspection",
    "href": "ho/ho2_1.html#data-inspection",
    "title": "1st Order Methods",
    "section": "1.3 Data Inspection",
    "text": "1.3 Data Inspection\n\nglimpse(childcare_sf, 70)\n\nRows: 2,290\nColumns: 3\n$ Name        &lt;chr&gt; \"kml_1\", \"kml_2\", \"kml_3\", \"kml_4\", \"kml_5\", \"km…\n$ Description &lt;chr&gt; \"&lt;center&gt;&lt;table&gt;&lt;tr&gt;&lt;th colspan='2' align='cente…\n$ geometry    &lt;POINT [m]&gt; POINT Z (25089.46 31299.16 0), POINT Z (27…\n\n\n\n1.3.1 Reveal Projection System\n\nChildcare CentresSingapore National BoundarySGP Master Planning Subzone Boundary\n\n\n\nst_crs(childcare_sf)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\n\n\n\nst_crs(sg_sf)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\n\n\n\nst_crs(mpsz_sf)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]"
  },
  {
    "objectID": "ho/ho2_1.html#data-preprocessing-projection-transformation",
    "href": "ho/ho2_1.html#data-preprocessing-projection-transformation",
    "title": "1st Order Methods",
    "section": "1.4 Data Preprocessing :: Projection Transformation",
    "text": "1.4 Data Preprocessing :: Projection Transformation\n\nsg_sf3414 &lt;- st_transform(sg_sf, \n                          crs = 3414)\n\n\nmpsz_sf3414 &lt;- st_transform(mpsz_sf, \n                            crs = 3414)"
  },
  {
    "objectID": "ho/ho2_1.html#data-visualisation",
    "href": "ho/ho2_1.html#data-visualisation",
    "title": "1st Order Methods",
    "section": "1.5 Data Visualisation",
    "text": "1.5 Data Visualisation\nNOTE : Interactive maps are more resource-intensive than static maps. Rendering many interactive maps in a single document can significantly increase the time it takes to knit the document and can cause performance issues such as slow to load or memory errors, especially if the document is viewed in a web browser. So, try to keep it below 10 usages within an RMarkdown.\n\ntmap_mode('view')\ntm_shape(childcare_sf) +\n  tm_dots(alpha = 0.5,\n          size = 0.01) +\n  tm_view(set.zoom.limits = c(11, 16))\n\n\n\n\n\n\n\ntmap_mode('plot')"
  },
  {
    "objectID": "ho/ho2_1.html#data-frame-conversion-into-spatial-class",
    "href": "ho/ho2_1.html#data-frame-conversion-into-spatial-class",
    "title": "1st Order Methods",
    "section": "2.1 Data Frame Conversion into Spatial* Class",
    "text": "2.1 Data Frame Conversion into Spatial* Class\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nas_Spatial( ) - sf- to convert simple feature, sf, data frame to sp object. Beware of the capital “S”.\n\n\n\n\nchildcare &lt;- as_Spatial(childcare_sf)\nmpsz &lt;- as_Spatial(mpsz_sf)\nsg &lt;- as_Spatial(sg_sf)\n\n\nREVEAL : PLANNING ZONENATIONAL BOUNDARYCHILDCARE\n\n\n\nmpsz\n\nclass       : SpatialPolygonsDataFrame \nfeatures    : 323 \nextent      : 2667.538, 56396.44, 15748.72, 50256.33  (xmin, xmax, ymin, ymax)\ncrs         : +proj=tmerc +lat_0=1.36666666666667 +lon_0=103.833333333333 +k=1 +x_0=28001.642 +y_0=38744.572 +datum=WGS84 +units=m +no_defs \nvariables   : 15\nnames       : OBJECTID, SUBZONE_NO, SUBZONE_N, SUBZONE_C, CA_IND, PLN_AREA_N, PLN_AREA_C,       REGION_N, REGION_C,          INC_CRC, FMEL_UPD_D,     X_ADDR,     Y_ADDR,    SHAPE_Leng,    SHAPE_Area \nmin values  :        1,          1, ADMIRALTY,    AMSZ01,      N, ANG MO KIO,         AM, CENTRAL REGION,       CR, 00F5E30B5C9B7AD8,      16409,  5092.8949,  19579.069, 871.554887798, 39437.9352703 \nmax values  :      323,         17,    YUNNAN,    YSSZ09,      Y,     YISHUN,         YS,    WEST REGION,       WR, FFCCF172717C2EAF,      16409, 50424.7923, 49552.7904, 68083.9364708,  69748298.792 \n\n\n\n\n\nmpsz\n\nclass       : SpatialPolygonsDataFrame \nfeatures    : 323 \nextent      : 2667.538, 56396.44, 15748.72, 50256.33  (xmin, xmax, ymin, ymax)\ncrs         : +proj=tmerc +lat_0=1.36666666666667 +lon_0=103.833333333333 +k=1 +x_0=28001.642 +y_0=38744.572 +datum=WGS84 +units=m +no_defs \nvariables   : 15\nnames       : OBJECTID, SUBZONE_NO, SUBZONE_N, SUBZONE_C, CA_IND, PLN_AREA_N, PLN_AREA_C,       REGION_N, REGION_C,          INC_CRC, FMEL_UPD_D,     X_ADDR,     Y_ADDR,    SHAPE_Leng,    SHAPE_Area \nmin values  :        1,          1, ADMIRALTY,    AMSZ01,      N, ANG MO KIO,         AM, CENTRAL REGION,       CR, 00F5E30B5C9B7AD8,      16409,  5092.8949,  19579.069, 871.554887798, 39437.9352703 \nmax values  :      323,         17,    YUNNAN,    YSSZ09,      Y,     YISHUN,         YS,    WEST REGION,       WR, FFCCF172717C2EAF,      16409, 50424.7923, 49552.7904, 68083.9364708,  69748298.792 \n\n\n\n\n\nchildcare\n\nclass       : SpatialPointsDataFrame \nfeatures    : 2290 \nextent      : 11810.03, 45404.24, 25596.33, 49300.88  (xmin, xmax, ymin, ymax)\ncrs         : +proj=tmerc +lat_0=1.36666666666667 +lon_0=103.833333333333 +k=1 +x_0=28001.642 +y_0=38744.572 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs \nvariables   : 2\nnames       :    Name,                                                                                                                                                                                                                                                                                                                                                                       Description \nmin values  :   kml_1, &lt;center&gt;&lt;table&gt;&lt;tr&gt;&lt;th colspan='2' align='center'&gt;&lt;em&gt;Attributes&lt;/em&gt;&lt;/th&gt;&lt;/tr&gt;&lt;tr bgcolor=\"#E3E3F3\"&gt; &lt;th&gt;CENTRE_NAME&lt;/th&gt; &lt;td&gt;3-IN-1 FAMILY CENTRE&lt;/td&gt; &lt;/tr&gt;&lt;tr bgcolor=\"\"&gt; &lt;th&gt;CENTRE_CODE&lt;/th&gt; &lt;td&gt;ST0027&lt;/td&gt; &lt;/tr&gt;&lt;tr bgcolor=\"#E3E3F3\"&gt; &lt;th&gt;INC_CRC&lt;/th&gt; &lt;td&gt;DF7EC9C2478FA5A5&lt;/td&gt; &lt;/tr&gt;&lt;tr bgcolor=\"\"&gt; &lt;th&gt;FMEL_UPD_D&lt;/th&gt; &lt;td&gt;20211201093631&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/center&gt; \nmax values  : kml_999,   &lt;center&gt;&lt;table&gt;&lt;tr&gt;&lt;th colspan='2' align='center'&gt;&lt;em&gt;Attributes&lt;/em&gt;&lt;/th&gt;&lt;/tr&gt;&lt;tr bgcolor=\"#E3E3F3\"&gt; &lt;th&gt;CENTRE_NAME&lt;/th&gt; &lt;td&gt;Zulfa Kindergarten&lt;/td&gt; &lt;/tr&gt;&lt;tr bgcolor=\"\"&gt; &lt;th&gt;CENTRE_CODE&lt;/th&gt; &lt;td&gt;PT9603&lt;/td&gt; &lt;/tr&gt;&lt;tr bgcolor=\"#E3E3F3\"&gt; &lt;th&gt;INC_CRC&lt;/th&gt; &lt;td&gt;527C1231DDD0FA64&lt;/td&gt; &lt;/tr&gt;&lt;tr bgcolor=\"\"&gt; &lt;th&gt;FMEL_UPD_D&lt;/th&gt; &lt;td&gt;20211201093632&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;"
  },
  {
    "objectID": "ho/ho2_1.html#data-frame-conversion-with-sp-package",
    "href": "ho/ho2_1.html#data-frame-conversion-with-sp-package",
    "title": "1st Order Methods",
    "section": "2.2 Data Frame Conversion with sp Package",
    "text": "2.2 Data Frame Conversion with sp Package\nAs one of the earliest packages for handling spatial data in R, the “sp” package provides classes for spatial data types that are prefixed with “Spatial”, such as SpatialPoints, SpatialPointsDataFrame, SpatialLines, SpatialPolygons, SpatialPolygonsDataFrame, etc.\nThe main differences between Spatial* classes and the generic sp object:\nSpatial* Classes\nThese classes are part of the “sp” package, which represents spatial data in R. They are S4 classes, which is a formal class system in R that allows for more rigorous data structure definition and method dispatch.\n\nEach Spatial* class is tailored to specific types of spatial data & includes slots for metadata such as coordinate reference systems (CRS), bounding box, and attributes.\n\nSpatialPoints & SpatialPointsDataFrame handle point data\nSpatialLines & SpatialLinesDataFrame handle line data\nSpatialPolygons & SpatialPolygonsDataFrame handle polygon data.\n\n\nGeneric sp Object\nThe term “generic sp object” may refer to any Spatial* classes since they all inherit from the base Spatial class in the “sp” package.\n\n2.2.1 Convert Spatial* class into generic sp format\n\nchildcare_sp &lt;- as(childcare, \"SpatialPoints\")\nsg_sp &lt;- as(sg, \"SpatialPolygons\")\n\n\n\n\n2.2.2 Convert generic sp format into spatstat’s ppp format\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nas_ppp( ) - spatstat - to convert data into spatial point pattern. This is done so it can be used with spatstat package.\n\n\n\n\nchildcare_ppp &lt;- as(childcare_sp, \"ppp\")\nchildcare_ppp\n\nPlanar point pattern: 2290 points\nwindow: rectangle = [11810.03, 45404.24] x [25596.33, 49300.88] units\n\n\n\nINSPECT DIFFERENCESSUMMARY\n\n\n\nplot(childcare_ppp)\n\n\n\n\n\n\n\nsummary(childcare_ppp)\n\nPlanar point pattern:  2290 points\nAverage intensity 2.875673e-06 points per square unit\n\n*Pattern contains duplicated points*\n\nCoordinates are given to 3 decimal places\ni.e. rounded to the nearest multiple of 0.001 units\n\nWindow: rectangle = [11810.03, 45404.24] x [25596.33, 49300.88] units\n                    (33590 x 23700 units)\nWindow area = 796335000 square units\n\n\nNOTE : Duplicated points may be due to points coinciding together.\n\n\n\n\n\n\n2.2.3 Manage Duplicated Points\n\n2.2.3.1 Verify any duplication\n\nany(duplicated(childcare_ppp))\n\n[1] TRUE\n\n\n\noptions(max.print = 5000)\n\nNOTE : Set the max.print to above 2,290 if there is a warning message - “[ reached getOption(”max.print”) - - omitted n entries ] when run the code chunk below.\n\nmultiplicity(childcare_ppp)\n\n\nsum(multiplicity(childcare_ppp) &gt; 1)\n\n[1] 885\n\n\n\n\n2.2.3.2 Visualise the duplication\n\n# create new object that captures each point multiplicity\nchildcare_multiplicity &lt;- multiplicity(childcare_ppp)\n\n# Convert the ppp object back to a `SpatialPoints` data frame\nchildcare_spdf &lt;- as(childcare_ppp, \"SpatialPoints\")\n\n# Add the multiplicity information to the `SpatialPoints` data frame\nchildcare_spdf$duplication &lt;- childcare_multiplicity &gt; 1\n\n# Convert back to an sf object\nchildcare_test &lt;- st_as_sf(childcare_spdf)\n\n# Ensure the projection is correct.\nchildcare_test3414 &lt;- st_set_crs(childcare_test, 3414)\n\n\ntm_shape(childcare_test3414) +\n  tm_dots(col = \"duplication\", \n          palette = c(\"black\", \"red\"), \n          size = 0.1,\n          title = 'Duplication') +\n  tm_layout(main.title = \"DATA POINT DUPLICATIONS\",\n            main.title.size = 1.2)\n\n\n\n\n\n\n2.2.3.2 Overcome duplication\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nrjitter( ) - spatstat - to introduce independent random perturbation to each point in a point pattern.\n\nretry when set to TRUE will perturb the point that lies outside the window of the original point pattern. Else, it will be lost.\nnsim set the quantity of simulated realisation to be generated.\ndrop by default TRUE to produce point pattern. Else, a list containing point patterns.\n\n\n\n\n\nSOLUTION : JITTERING\n\n\n\nchildcare_ppp_jit &lt;- rjitter(childcare_ppp,\n                             retry = TRUE, \n                             nsim = 1, \n                             drop = TRUE)\n\n\nrjitter(childcare_ppp,\n        retry = TRUE,\n        nsim = 2,\n        drop = FALSE)\n\nList of point patterns\n\nSimulation 1:\nPlanar point pattern: 2290 points\nwindow: rectangle = [11810.03, 45404.24] x [25596.33, 49300.88] units\n\nSimulation 2:\nPlanar point pattern: 2290 points\nwindow: rectangle = [11810.03, 45404.24] x [25596.33, 49300.88] units\n\n\n\nany(duplicated(childcare_ppp_jit))\n\n[1] FALSE\n\n\n\nchildcare_ppp_jit0 &lt;- multiplicity(childcare_ppp_jit)\n\n# Convert the ppp object back to a `SpatialPoints` data frame\nchildcare_spdf0 &lt;- as(childcare_ppp_jit, \"SpatialPoints\")\n\n# Add the multiplicity information to the `SpatialPoints` data frame\nchildcare_spdf0$duplication &lt;- childcare_ppp_jit0 &gt; 1\n\n# Convert back to an sf object\nchildcare_test0 &lt;- st_as_sf(childcare_spdf0)\n\n# Ensure the projection is correct.\nchildcare_test34140 &lt;- st_set_crs(childcare_test0, 3414)\n\n\ntm_shape(childcare_test34140) +\n  tm_dots(col = \"duplication\", \n          palette = c(\"black\", \"red\"), \n          size = 0.1,\n          title = 'Duplication') +\n  tm_layout(main.title = \"DATA POINT DUPLICATIONS\",\n            main.title.size = 1.2)"
  },
  {
    "objectID": "ho/ho2_1.html#creating-owin-object",
    "href": "ho/ho2_1.html#creating-owin-object",
    "title": "1st Order Methods",
    "section": "2.3 Creating owin Object",
    "text": "2.3 Creating owin Object\nowin short for “observation window”. The region within this window where the spatial data (points, lines or polygons) are observed. The owin function is fundamental to define the spatial context for your point pattern analysis. It ensures that any spatial patterns or processes you are studying are constrained to a specific area of interest.\nIn the context of spatstat and point pattern analysis, this window can be interpreted as the outermost boundary or the extent of the study area for spatial data in other types of spatial analysis, such as tm_shape() from tmap. This extent defines the area over which the map is drawn and is determined by the bounding coordinates of the spatial object you are plotting.\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nowin( ) - spatstat - to create a window, i.e. Singapore land boundary.\n\nNOTE : There are 2 ways to perform this function. Below code chunk is the alternative approach.\n\n\n\n\n\nsg_owin &lt;- as(sg_sp, \"owin\")\n\n\nplot(sg_owin)\n\n\n\n\n\nsummary(sg_owin)\n\nWindow: polygonal boundary\n60 separate polygons (no holes)\n            vertices        area relative.area\npolygon 1         38 1.56140e+04      2.09e-05\npolygon 2        735 4.69093e+06      6.27e-03\npolygon 3         49 1.66986e+04      2.23e-05\npolygon 4         76 3.12332e+05      4.17e-04\npolygon 5       5141 6.36179e+08      8.50e-01\npolygon 6         42 5.58317e+04      7.46e-05\npolygon 7         67 1.31354e+06      1.75e-03\npolygon 8         15 4.46420e+03      5.96e-06\npolygon 9         14 5.46674e+03      7.30e-06\npolygon 10        37 5.26194e+03      7.03e-06\npolygon 11        53 3.44003e+04      4.59e-05\npolygon 12        74 5.82234e+04      7.78e-05\npolygon 13        69 5.63134e+04      7.52e-05\npolygon 14       143 1.45139e+05      1.94e-04\npolygon 15       165 3.38736e+05      4.52e-04\npolygon 16       130 9.40465e+04      1.26e-04\npolygon 17        19 1.80977e+03      2.42e-06\npolygon 18        16 2.01046e+03      2.69e-06\npolygon 19        93 4.30642e+05      5.75e-04\npolygon 20        90 4.15092e+05      5.54e-04\npolygon 21       721 1.92795e+06      2.57e-03\npolygon 22       330 1.11896e+06      1.49e-03\npolygon 23       115 9.28394e+05      1.24e-03\npolygon 24        37 1.01705e+04      1.36e-05\npolygon 25        25 1.66227e+04      2.22e-05\npolygon 26        10 2.14507e+03      2.86e-06\npolygon 27       190 2.02489e+05      2.70e-04\npolygon 28       175 9.25904e+05      1.24e-03\npolygon 29      1993 9.99217e+06      1.33e-02\npolygon 30        38 2.42492e+04      3.24e-05\npolygon 31        24 6.35239e+03      8.48e-06\npolygon 32        53 6.35791e+05      8.49e-04\npolygon 33        41 1.60161e+04      2.14e-05\npolygon 34        22 2.54368e+03      3.40e-06\npolygon 35        30 1.08382e+04      1.45e-05\npolygon 36       327 2.16921e+06      2.90e-03\npolygon 37       111 6.62927e+05      8.85e-04\npolygon 38        90 1.15991e+05      1.55e-04\npolygon 39        98 6.26829e+04      8.37e-05\npolygon 40       415 3.25384e+06      4.35e-03\npolygon 41       222 1.51142e+06      2.02e-03\npolygon 42       107 6.33039e+05      8.45e-04\npolygon 43         7 2.48299e+03      3.32e-06\npolygon 44        17 3.28303e+04      4.38e-05\npolygon 45        26 8.34758e+03      1.11e-05\npolygon 46       177 4.67446e+05      6.24e-04\npolygon 47        16 3.19460e+03      4.27e-06\npolygon 48        15 4.87296e+03      6.51e-06\npolygon 49        66 1.61841e+04      2.16e-05\npolygon 50       149 5.63430e+06      7.53e-03\npolygon 51       609 2.62570e+07      3.51e-02\npolygon 52         8 7.82256e+03      1.04e-05\npolygon 53       976 2.33447e+07      3.12e-02\npolygon 54        55 8.25379e+04      1.10e-04\npolygon 55       976 2.33447e+07      3.12e-02\npolygon 56        61 3.33449e+05      4.45e-04\npolygon 57         6 1.68410e+04      2.25e-05\npolygon 58         4 9.45963e+03      1.26e-05\npolygon 59        46 6.99702e+05      9.35e-04\npolygon 60        13 7.00873e+04      9.36e-05\nenclosing rectangle: [2663.93, 56047.79] x [16357.98, 50244.03] units\n                     (53380 x 33890 units)\nWindow area = 748741000 square units\nFraction of frame area: 0.414"
  },
  {
    "objectID": "ho/ho2_1.html#combining-owin-object-point-events-object",
    "href": "ho/ho2_1.html#combining-owin-object-point-events-object",
    "title": "1st Order Methods",
    "section": "2.4 Combining owin Object & Point Events Object",
    "text": "2.4 Combining owin Object & Point Events Object\n\nchildcareSG_ppp = childcare_ppp[sg_owin]\n\n\nsummary(childcareSG_ppp)\n\nPlanar point pattern:  2290 points\nAverage intensity 3.058467e-06 points per square unit\n\n*Pattern contains duplicated points*\n\nCoordinates are given to 3 decimal places\ni.e. rounded to the nearest multiple of 0.001 units\n\nWindow: polygonal boundary\n60 separate polygons (no holes)\n            vertices        area relative.area\npolygon 1         38 1.56140e+04      2.09e-05\npolygon 2        735 4.69093e+06      6.27e-03\npolygon 3         49 1.66986e+04      2.23e-05\npolygon 4         76 3.12332e+05      4.17e-04\npolygon 5       5141 6.36179e+08      8.50e-01\npolygon 6         42 5.58317e+04      7.46e-05\npolygon 7         67 1.31354e+06      1.75e-03\npolygon 8         15 4.46420e+03      5.96e-06\npolygon 9         14 5.46674e+03      7.30e-06\npolygon 10        37 5.26194e+03      7.03e-06\npolygon 11        53 3.44003e+04      4.59e-05\npolygon 12        74 5.82234e+04      7.78e-05\npolygon 13        69 5.63134e+04      7.52e-05\npolygon 14       143 1.45139e+05      1.94e-04\npolygon 15       165 3.38736e+05      4.52e-04\npolygon 16       130 9.40465e+04      1.26e-04\npolygon 17        19 1.80977e+03      2.42e-06\npolygon 18        16 2.01046e+03      2.69e-06\npolygon 19        93 4.30642e+05      5.75e-04\npolygon 20        90 4.15092e+05      5.54e-04\npolygon 21       721 1.92795e+06      2.57e-03\npolygon 22       330 1.11896e+06      1.49e-03\npolygon 23       115 9.28394e+05      1.24e-03\npolygon 24        37 1.01705e+04      1.36e-05\npolygon 25        25 1.66227e+04      2.22e-05\npolygon 26        10 2.14507e+03      2.86e-06\npolygon 27       190 2.02489e+05      2.70e-04\npolygon 28       175 9.25904e+05      1.24e-03\npolygon 29      1993 9.99217e+06      1.33e-02\npolygon 30        38 2.42492e+04      3.24e-05\npolygon 31        24 6.35239e+03      8.48e-06\npolygon 32        53 6.35791e+05      8.49e-04\npolygon 33        41 1.60161e+04      2.14e-05\npolygon 34        22 2.54368e+03      3.40e-06\npolygon 35        30 1.08382e+04      1.45e-05\npolygon 36       327 2.16921e+06      2.90e-03\npolygon 37       111 6.62927e+05      8.85e-04\npolygon 38        90 1.15991e+05      1.55e-04\npolygon 39        98 6.26829e+04      8.37e-05\npolygon 40       415 3.25384e+06      4.35e-03\npolygon 41       222 1.51142e+06      2.02e-03\npolygon 42       107 6.33039e+05      8.45e-04\npolygon 43         7 2.48299e+03      3.32e-06\npolygon 44        17 3.28303e+04      4.38e-05\npolygon 45        26 8.34758e+03      1.11e-05\npolygon 46       177 4.67446e+05      6.24e-04\npolygon 47        16 3.19460e+03      4.27e-06\npolygon 48        15 4.87296e+03      6.51e-06\npolygon 49        66 1.61841e+04      2.16e-05\npolygon 50       149 5.63430e+06      7.53e-03\npolygon 51       609 2.62570e+07      3.51e-02\npolygon 52         8 7.82256e+03      1.04e-05\npolygon 53       976 2.33447e+07      3.12e-02\npolygon 54        55 8.25379e+04      1.10e-04\npolygon 55       976 2.33447e+07      3.12e-02\npolygon 56        61 3.33449e+05      4.45e-04\npolygon 57         6 1.68410e+04      2.25e-05\npolygon 58         4 9.45963e+03      1.26e-05\npolygon 59        46 6.99702e+05      9.35e-04\npolygon 60        13 7.00873e+04      9.36e-05\nenclosing rectangle: [2663.93, 56047.79] x [16357.98, 50244.03] units\n                     (53380 x 33890 units)\nWindow area = 748741000 square units\nFraction of frame area: 0.414\n\n\n\nplot(childcareSG_ppp)"
  },
  {
    "objectID": "ho/ho2_1.html#kernel-density-estimation",
    "href": "ho/ho2_1.html#kernel-density-estimation",
    "title": "1st Order Methods",
    "section": "3.1 Kernel Density Estimation",
    "text": "3.1 Kernel Density Estimation\nKDE is a non-parametric way (doesn’t assume the childcare centres to follow any particular pattern or rule) to estimate the probability density function of points across the study area. This technique is useful to facilitate stakeholders to visualise the distribution of childcare centres across Singapore and identify areas of high & low concentrations.\nNOTE : For beginners who are confused - this statement “estimating the probability density” is a statistical way of talking about how likely you are to find a childcare centre if you were to look at a random spot in Singapore. KDE takes the actual locations of all the childcare centres to make an educated guess (estimate) of the likelihood (probability) or change of finding a centre in any given area.\nThere are multiple approaches for KDE -\n\nAutomatic bandwidth selection method\n\n\n3.1.1 Automatic bandwidth selection methods\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\ndensity( ) - spatstat - to compute a kernel smoothed intensity function from a point pattern.\n\nSigma argument to adjust the level of smoothing with a single numerical value as the smoothing bandwidth. There are 4 functions, bw.diggle, bw.CvL, bw.scott or bw.ppl to perform automatic bandwidth using cross-validation. If this argument is not specified, the isotropic Gaussian kernel will be used to compute the sigma value.\nNOTE : If any of you are struggling to grasp the concept of Bandwidth (sigma) - Think of the bandwidth as the width of the smoothing brush you use to pain the intensity of points on a map. A larger brush (bandwidth) paints over a larger area, smoothing out the details and showing a broader trend. A smaller brush reveals more local detail but can be noisier. (the metaphor credited to Uriel)\nedge to apply edge effect bias correction for the intensity estimation when TRUE. Default is TRUE.\nkernel default value is “gaussian”. Other options epanechnikov, quartic and disc.\nNOTE : Again, credits to Uriel - The kernel is a function that defines the shape of the “brush” used to “paint” the intensity of the point pattern on the study area. It assigns weights to points within a certain region, with the weights typically decreasing with distance from the centre of the kernel.\nscalekernel default value is TRUE when the kernel is a character string instead of a pixel image. When it’s true, the kernel shape is consistent across different bandwidths. This is useful when comparing KDE results across different bandwidths. Can consider FALSE when intended to explore how the bandwidth can alter the shape of kernel.\n\n\n\n\n\nSIGMA : bw.digglebw.scottbw.CvLbw.fracbw.ppl\n\n\nThis method uses the average distance between points and the total area of the study region to determine an appropriate bandwidth.\n\nkde_childcareSG_bw &lt;- density(childcareSG_ppp,\n                              sigma = bw.diggle,\n                              edge = TRUE,\n                              kernel = \"gaussian\")\nplot(kde_childcareSG_bw)\n\n\n\n\n\nbw.diggle(childcareSG_ppp)\n\n   sigma \n281.8312 \n\n\n\n\nThis option is useful for estimating gradual trend as it produces a larger bandwidth than diggle.\nAccording to the Scott’s rule : the bandwidth is proportional to n-1/(d+4) where,\n\nn = the number of points\n\nHaving more points means smaller bandwidth will be - have more information, thus can afford to look at finer details.\n\nd = the number of spatial dimensions, typically 2 for a map (x & y dimensions).\n\nHaving more dimensions means larger the bandwidth will be.\n\n\nNOTE : bw.scott has an option to use isotropic bandwidth. When isotropic = TRUE, use same bandwidth in all directions. If FALSE (default), calculate different bandwidths for different directions. The latter is useful when the points distribution is different in the x and y directions.\n\n#isotropic is FALSE(default)\nkde_childcareSG_bwsct &lt;- density(childcareSG_ppp,\n                                 sigma = bw.scott,\n                                 edge = TRUE,\n                                 kernel = \"gaussian\")\nplot(kde_childcareSG_bwsct)\n\n\n\n\n\nbw.scott(childcareSG_ppp)\n\n sigma.x  sigma.y \n2111.666 1347.496 \n\n\n\n#isotropic set to TRUE, the differences are observed btw these 2 plots.\nkde_childcareSG_bwsctf &lt;- density(childcareSG_ppp,\n                                 sigma = bw.scott(childcareSG_ppp, \n                                                  isotropic = TRUE),\n                                 edge = TRUE,\n                                 kernel = \"gaussian\")\nplot(kde_childcareSG_bwsctf)\n\n\n\n\n\nbw.scott(childcareSG_ppp, isotropic = TRUE)\n\n  sigma \n1686.85 \n\n\n\n\nUses Cronie & van Lieshout’s Criterion to select the smoothing bandwidth.\nCvL(σ) = ( |W| - Sum [ 1 / λ̂ (xi) ] )2\nThe goal is to find the bandwidth σ that minimise the discrepancy between the area of the observation window and the sum of reciprocal estimated intensity.\n\nThis is done by identifying the balance where the estimated density is neither too wiggly (overfitting to the data points) nor too smooth (underfitting and missing important features).\nThe bandwidth that gives the lowest value of the criterion is chosen as the best one.\nMeaning, according to cross-validation likelihood, the selected bandwidth will provide the most reliable density estimate that perform well both in representing the high-density areas (where points are clustered) and avoiding to be mislead by random fluctuations or noise in the spatial distribution of the childcare centres.\n\n\nkde_childcareSG_bwcvl &lt;- density(childcareSG_ppp,\n                                 sigma = bw.CvL,\n                                 edge = TRUE,\n                                 kernel = \"gaussian\")\nplot(kde_childcareSG_bwcvl)\n\n\n\n\n\nbw.CvL(childcareSG_ppp)\n\n   sigma \n4543.278 \n\n\n\n\nThis option is an quantile-based bandwidth. The σ is selected such that a certain percentage (quantile) of all pairwise distances between independent random points is below it.\nBy default, it uses the lower quartile, i.e. the bandwidth smaller than 25% of all pairwise distances. This allows it to focus on the denser core areas of distribution, providing a clear visualisation of where childcare services are most concentrated.\n\nkde_childcareSG_bwfra &lt;- density(childcareSG_ppp,\n                              sigma = bw.frac,\n                              edge = FALSE,\n                              kernel = \"gaussian\")\nplot(kde_childcareSG_bwfra)\n\n\n\n\n\nbw.frac(childcareSG_ppp)\n\n[1] 9604.676\n\n\n\n\nppl shorts for “plug-in predictor”, estimates the bandwidth that would minimise the mean squared error of the density estimate. Compared to bw.diggle, bw.ppl can be more accurate but computationally more intensive.\n\nkde_childcareSG_bwppl &lt;- density(childcareSG_ppp,\n                              sigma = bw.ppl,\n                              edge = FALSE,\n                              kernel = \"gaussian\")\nplot(kde_childcareSG_bwppl)\n\n\n\n\n\nbw.ppl(childcareSG_ppp)\n\n   sigma \n210.9048 \n\n\n\n\n\n\n\n3.1.2 Rescaling KDE value\nDefault unit for svy21 is in meter. Hence, the computed density values above are in n points per square meter (the colour bar legend on the right).\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nrescale( ) - spatstat - to convert the childcareSG_ppp from meter to kilometer.\n\n\n\n\nchildcareSG_ppp.km &lt;- rescale(childcareSG_ppp, 1000, \"km\")\n\n\nSIGMA : bw.digglebw.scottbw.CvLbw.fracbw.ppl\n\n\n\nkde_childcareSG_bwdig &lt;- density(childcareSG_ppp.km,\n                              sigma = bw.diggle,\n                              edge = TRUE,                  \n                              kernel = \"gaussian\") \nplot(kde_childcareSG_bwdig)\n\n\n\n\n\nbw.diggle(childcareSG_ppp.km)\n\n    sigma \n0.2818312 \n\n\n\n\n\n#isotropic is FALSE(default) \nkde_childcareSG_bwsct &lt;- density(childcareSG_ppp.km,                       \n                                 sigma = bw.scott,                        \n                                 edge = TRUE,                           \n                                 kernel = \"gaussian\") \nplot(kde_childcareSG_bwsct)\n\n\n\n\n\n#isotropic set to TRUE, the differences are observed btw these 2 plots. \nkde_childcareSG_bwsctf &lt;- density(childcareSG_ppp.km,                         \n                                  sigma = bw.scott(childcareSG_ppp,            \n                                                   isotropic = TRUE),         \n                                  edge = TRUE,                                \n                                  kernel = \"gaussian\") \nplot(kde_childcareSG_bwsctf)\n\n\n\n\n\n\n\nkde_childcareSG_bwcvl &lt;- density(childcareSG_ppp.km,                          \n                                 sigma = bw.CvL,                          \n                                 edge = TRUE,                           \n                                 kernel = \"gaussian\") \nplot(kde_childcareSG_bwcvl)\n\n\n\n\n\n\n\nkde_childcareSG_bwfra &lt;- density(childcareSG_ppp.km,                         \n                                 sigma = bw.frac,                             \n                                 edge = FALSE,                          \n                                 kernel = \"gaussian\") \nplot(kde_childcareSG_bwfra)\n\n\n\n\n\n\n\nkde_childcareSG_bwppl &lt;- density(childcareSG_ppp.km,                        \n                                 sigma = bw.ppl,                               \n                                 edge = FALSE,                               \n                                 kernel = \"gaussian\") \nplot(kde_childcareSG_bwppl)\n\n\n\n\n\n\n\nAfter comparing the outputs from these options, for the context of this post, that is, the distribution of childcare centres, one may want to consider using -\n\nbw.ppl option can produce more appropriate values when the pattern consists predominantly of tight clusters.\nbw.diggle option is more suitable when the goal is to detect a single tight cluster among random noise.\n\n\nplot(kde_childcareSG_bwdig, main = \"bw.diggle\")\n\n\n\nplot(kde_childcareSG_bwppl, main = \"bw.ppl\")\n\n\n\n\n\n\n3.1.3 Different Kernel Methods\nNOTE :\n\nIf scalekernel set to TRUE, the KDE map for childcare centres will be more uniform / standardised view and smoother variations in density.\nIf FALSE, may be able to highlight local clusters or gaps more distinctly, but also making the results more sensitive to the choice of bandwidth.\n\n\nKERNEL : GAUSSIANEPANECHNIKOVQUARTICDISC\n\n\nThis assigns weights to points based on the Gaussian (normal) distribution. It gives higher weights to points closer to the centre of the kernel and gradually less to points further away, without ever reaching zero.\nUSE CASES (credits to Uriel) :\n\nWithout prior knowledge about the distribution of points and want a smooth, infinitely differentiable estimate.\nFor environmental data analysis, especially modelling pollution dispersion which follows a gradient descent similar to a Gaussian distribution.\n\n\nplot(density(childcareSG_ppp.km, \n             sigma = bw.ppl, \n             edge = TRUE, \n             kernel = \"gaussian\"), \n     main = \"Gaussian\")\n\n\n\n\n\n\nThis kernel is parabolic and has a finite support. It only assign weights to points within a certain distance. Though, it is more computationally efficient than the Gaussian kernel.\nUSE CASES :\n\nWhen study area is large and intended to ignore very distant points.\nEstimate animal home ranges in wildlife studies. Except for certain wild beings like sea turtle or salmon, observations far from centre are less likely to influence the home range estimate.\n\n\nplot(density(childcareSG_ppp.km, \n             sigma = bw.ppl, \n             edge = TRUE, \n             kernel = \"epanechnikov\"), \n     main = \"Epanechnikov\")\n\n\n\n\n\n\nThis kernel option is similar to Epanechnikov kernel, has finite support, but uses a biweight algorithm that offering bell-shaped weighting.\nUSE CASES :\n\nWhen require properties of Gaussian’s smooth estimate and Epanechnikov’s finite support property.\nFor crime analysis that focus on hotspots but still consider a tapering effect for incidents that occur near the edge of these hotspots.\n\n\nplot(density(childcareSG_ppp.km, \n             sigma = bw.ppl, \n             edge = TRUE, \n             kernel = \"quartic\"), \n     main = \"Quartic\")\n\n\n\n\n\n\nThis option assign equal weight to all points within a certain radius and zero weight to points outside. This is the simplest form of kernel with a hard cut-off.\nUSE CASES :\n\nModel phenomena with a uniform influence within a set distance, such as the coverage area of a cell tower.\nEvaluate the catchment area of store, in retail analysis, where all customers within a certain radius are considered equally likely to visit.\n\n\nplot(density(childcareSG_ppp.km, \n             sigma = bw.ppl, \n             edge = TRUE, \n             kernel = \"disc\"), \n     main = \"Disc\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nmfrow( ) - RcmdrPlugin - to create a matrix layout for plot array.\n\n\n\n\npar(mfrow = c(2,2))\nplot(density(childcareSG_ppp.km, \n             sigma = bw.ppl, \n             edge = TRUE, \n             kernel = \"gaussian\"), \n     main = \"Gaussian\")\n\nplot(density(childcareSG_ppp.km, \n             sigma = bw.ppl, \n             edge = TRUE, \n             kernel = \"epanechnikov\"), \n     main = \"Epanechnikov\")\n\nplot(density(childcareSG_ppp.km, \n             sigma = bw.ppl, \n             edge = TRUE, \n             kernel = \"quartic\"), \n     main = \"Quartic\")\n\nplot(density(childcareSG_ppp.km, \n             sigma = bw.ppl, \n             edge = TRUE, \n             kernel = \"disc\"), \n     main = \"Disc\")\n\n\n\n\n\n\n3.1.4 Fixed Bandwidth vs. Adaptive Bandwidth\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nadaptive.density( ) - spatstat - to computes an adaptive estimation.\n\nmethod is set to voronoi, the data will be parsed under densityVoronoi which estimate intensity based on Voronoi Dirichlet tessellation.\n\n\n\n\n\nFIXED BANDWIDTHADAPTIVE BANDWIDTH\n\n\nThe following attempt will be using 500 meter, i.e. sigma = 0.5 since childcareSG_ppp.km is in kilometer.\n\nkde_childcareSG_500 &lt;- density(childcareSG_ppp.km, \n                               sigma = 0.5, \n                               edge = TRUE, \n                               kernel = \"gaussian\")\nplot(kde_childcareSG_500, \n     main = \"Fixed Bandwidth : 500 meter\")\n\n\n\n\n\n\nUnlike fixed bandwidth, this approach has lower sensitive towards highly skewed distribution of spatial point patterns over geographical units.\nKernel Method\nThe adaptive kernel allows the bandwidth to vary with the local density of points, meaning it can adapt to the underlying structure of the point pattern.\nUSE CASES :\n\nVisualise crime hotspots in a city where areas with high crime rates are smoothed differently from low-rate areas, providing a detailed intensity map.\nIdentify clusters of high disease prevalence in mapping disease incidence rates. The smoothing adjusted for areas with varying case numbers.\n\n\nkde_childcareSG_adaptive &lt;- adaptive.density(childcareSG_ppp.km, \n                                             method = \"kernel\")\nplot(kde_childcareSG_adaptive,\n     main = \"Adaptive : Kernel Method\")\n\n\n\n\nVoronoi Method\nAs shown in the plot below, this approach partitioned the study area into regions around each point. The intensity estimate at any location is inversely proportional to the area of the Voronoi cell that contains the location.\nUSE CASES :\n\nEstimate animal territories or home ranges in ecological studies where each point represents an animal sighting. This method can give an estimate of the area dominated by each sighting.\nEstimate the influence area of public facilities like parks or libraries in urban planning, where each facility is expected to serve the nearest neighbourhood.\n\n\nkde_childcareSG_adaptive &lt;- adaptive.density(childcareSG_ppp.km, \n                                             method = \"voronoi\")\nplot(kde_childcareSG_adaptive,\n     main = \"Adaptive : Voronoi Method\")\n\n\n\n\nNOTE : The key difference between the 2 methods - how they approach the estimation of intensity. The voronoi output tend to be more discrete and polygon-based while the kernel output is more continuous and smooth (based on local point density).\n\n\n\n\n\n3.1.5 Convert KDE output into grid object\n\n3.1.5.1 Convert into gridded kernal density object\n\n\n\n\n\n\n⇳ Usage of the code chunk below :\n\n\n\n\n\nSpatialGridDataFrame( ) - sp - to convert into gridded data structure.\n\n\n\n\ngridded_kde_childcareSG_bw &lt;- as.SpatialGridDataFrame.im(kde_childcareSG_bwdig)\n\n\nspplot(gridded_kde_childcareSG_bw)\n\n\n\n\n\n\n3.1.5.2 Convert gridded kernal density object into RasterLayer object\n\nkde_childcareSG_bw_raster &lt;- raster(gridded_kde_childcareSG_bw)\n\n\nkde_childcareSG_bw_raster\n\nclass      : RasterLayer \ndimensions : 128, 128, 16384  (nrow, ncol, ncell)\nresolution : 0.4170614, 0.2647348  (x, y)\nextent     : 2.663926, 56.04779, 16.35798, 50.24403  (xmin, xmax, ymin, ymax)\ncrs        : NA \nsource     : memory\nnames      : v \nvalues     : -1.274202e-14, 41.20628  (min, max)\n\n\n\n\n3.1.5.3 Assign CRS to RasterLayer object\n\nprojection(kde_childcareSG_bw_raster) &lt;- CRS(\"+init=EPSG:3414\")\nkde_childcareSG_bw_raster\n\nclass      : RasterLayer \ndimensions : 128, 128, 16384  (nrow, ncol, ncell)\nresolution : 0.4170614, 0.2647348  (x, y)\nextent     : 2.663926, 56.04779, 16.35798, 50.24403  (xmin, xmax, ymin, ymax)\ncrs        : +proj=tmerc +lat_0=1.36666666666667 +lon_0=103.833333333333 +k=1 +x_0=28001.642 +y_0=38744.572 +ellps=WGS84 +units=m +no_defs \nsource     : memory\nnames      : v \nvalues     : -1.274202e-14, 41.20628  (min, max)\n\n\n\n\n3.1.5.4 Visualise RasterLayer object\n\ntm_shape(kde_childcareSG_bw_raster) + \n  tm_raster(\"v\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\"), \n            frame = FALSE)\n\n\n\n\n\n\nComparing Spatial Point Patterns using KDE\n\n\nStep 1 - Extracting study area\n\npg = mpsz[mpsz@data$PLN_AREA_N == \"PUNGGOL\",]\ntm = mpsz[mpsz@data$PLN_AREA_N == \"TAMPINES\",]\nck = mpsz[mpsz@data$PLN_AREA_N == \"CHOA CHU KANG\",]\njw = mpsz[mpsz@data$PLN_AREA_N == \"JURONG WEST\",]\n\nStep 2 - Plotting target planning areas\n\npar(mfrow=c(2,2)) \nplot(pg, main = \"Ponggol\") \nplot(tm, main = \"Tampines\") \nplot(ck, main = \"Choa Chu Kang\") \nplot(jw, main = \"Jurong West\")\n\n\n\n\nStep 3 - Converting the spatial point data frame into generic sp format\n\npg_sp = as(pg, \"SpatialPolygons\") \ntm_sp = as(tm, \"SpatialPolygons\") \nck_sp = as(ck, \"SpatialPolygons\") \njw_sp = as(jw, \"SpatialPolygons\")\n\nStep 4 - Creating owin object\n\npg_owin = as(pg_sp, \"owin\") \ntm_owin = as(tm_sp, \"owin\") \nck_owin = as(ck_sp, \"owin\") \njw_owin = as(jw_sp, \"owin\")\n\nStep 5 - Combining childcare points and the study area\n\nchildcare_pg_ppp = childcare_ppp_jit[pg_owin] \nchildcare_tm_ppp = childcare_ppp_jit[tm_owin] \nchildcare_ck_ppp = childcare_ppp_jit[ck_owin] \nchildcare_jw_ppp = childcare_ppp_jit[jw_owin]\n\nStep 6 - Rescale the data\n\nchildcare_pg_ppp.km = rescale(childcare_pg_ppp, 1000, \"km\")\nchildcare_tm_ppp.km = rescale(childcare_tm_ppp, 1000, \"km\")\nchildcare_ck_ppp.km = rescale(childcare_ck_ppp, 1000, \"km\")\nchildcare_jw_ppp.km = rescale(childcare_jw_ppp, 1000, \"km\")\n\nStep 7 - Visualise\n\npar(mfrow = c(2,2))\nplot(childcare_pg_ppp.km, main = \"Punggol\")\nplot(childcare_tm_ppp.km, main = \"Tampines\")\nplot(childcare_ck_ppp.km, main = \"Choa Chu Kang\")\nplot(childcare_jw_ppp.km, main = \"Jurong West\")\n\n\n\n\nStep 8 - Compute KDE\n\npar(mfrow = c(2,2))\nplot(density(childcare_pg_ppp.km, \n             sigma = bw.diggle, \n             edge = TRUE, \n             kernel = \"gaussian\"),\n     main = \"Punggol\")\n\nplot(density(childcare_tm_ppp.km, \n             sigma = bw.diggle, \n             edge = TRUE, \n             kernel = \"gaussian\"),\n     main = \"Tempines\")\n\nplot(density(childcare_ck_ppp.km, \n             sigma = bw.diggle, \n             edge = TRUE, \n             kernel = \"gaussian\"),\n     main = \"Choa Chu Kang\")\n\nplot(density(childcare_jw_ppp.km, \n             sigma = bw.diggle, \n             edge = TRUE, \n             kernel = \"gaussian\"),\n     main = \"JUrong West\")\n\n\n\n\nStep 9 - Compute fixed bandwidth KDE\n\npar(mfrow = c(2,2))\nplot(density(childcare_ck_ppp.km, \n             sigma = 0.25, \n             edge = TRUE, \n             kernel = \"gaussian\"),\n     main = \"Chou Chu Kang\")\n\nplot(density(childcare_jw_ppp.km, \n             sigma = 0.25, \n             edge = TRUE, \n             kernel = \"gaussian\"),\n     main = \"JUrong West\")\n\nplot(density(childcare_pg_ppp.km, \n             sigma = 0.25, \n             edge = TRUE, \n             kernel = \"gaussian\"),\n     main = \"Punggol\")\n\nplot(density(childcare_tm_ppp.km, \n             sigma = 0.25, \n             edge = TRUE, \n             kernel = \"gaussian\"),\n     main = \"Tampines\")\n\n\n\n\n\n\n\n\nTAB1 : TEMPLATETAB2"
  }
]