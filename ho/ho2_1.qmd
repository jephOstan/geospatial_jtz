---
title: "1st Order Methods"
subtitle: "Spatial Point Patterns Analysis (SPPA)"
editor: visual
date: 8 Dec 2023
date-modified: "`r Sys.Date()`"
code-copy: true
execute: 
  echo: true
  eval: true
  warning: false
  error: false
website: 
    google-analytics: "G-SGM5SNE7BQ"
format:
  html:
    code-overflow: wrap
    code-fold: false
    code-summary: "Show the code"
    css: styles.css
---

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## [**CREDIT**]{style="color:#3a9c88"}

Once again, the credit for the code chunks and the key content of this post to [Dr. Kam Tin Seong](https://faculty.smu.edu.sg/profile/kam-tin-seong-486 "Geospatial Analytics Lecturer"), my geospatial analytics lecturer at the School of Computing and Information Systems, Singapore Management University. He has helped me tremendously, from having zero knowledge and programming background to comfortably using R for geospatial analysis.

Also, credits for some examples and explanation to Uriel, my ChatGPT ( OpenAI ) buddy, named him after the Archangel of Wisdom :)
:::

Spatial Point Pattern Analysis (SPPA) is a branch of spatial statistics that focuses on analysing patterns formed by points in space. This analysis is typically divided into first-order and second-order characteristics.

+-------------+--------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|             | First-Order Analysis                                                                                                                       | Second-Order Analysis                                                                                                                                                   |
+=============+============================================================================================================================================+=========================================================================================================================================================================+
| Description | Focuses on -                                                                                                                               | Focus on the interactions between points -                                                                                                                              |
|             |                                                                                                                                            |                                                                                                                                                                         |
|             | **Density Function** Measures the estimated number of points per unit area, without considering the presence of other points.              | **Ripley's K-function** A cumulative measure of spatial dependence that evaluates whether the pattern exhibits clustering, randomness, or regularity at various scales. |
|             |                                                                                                                                            |                                                                                                                                                                         |
|             | **Inhomogeneous Poisson Process** A model where the density or intensity of points can vary from place to place.                           | **Pair Correlation Function** Similar to the K-function but gives a non-cumulative measure of spatial dependence.                                                       |
|             |                                                                                                                                            |                                                                                                                                                                         |
|             | **Covariate Analysis** Examining how the density or intensity of points is related to environmental variables or other covariates.         | **Cross K-function** Used for multivariate point patterns to measure interactions between points of different types.                                                    |
+-------------+--------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Use Cases   | **Ecological Studies** Estimating the intensity of tree occurrences in different parts of a forest to identify areas of high tree density. | **Crime Analysis** Understanding the spatial clustering of crime incidents to discern patterns and possibly underlying causes.                                          |
|             |                                                                                                                                            |                                                                                                                                                                         |
|             | **Epidemiology** Mapping the intensity of disease cases to identify hotspots for targeted public health interventions.                     | **Ecology** Studying the inter-species interactions in an ecosystem by analyzing the spatial relationships between two different species.                               |
|             |                                                                                                                                            |                                                                                                                                                                         |
|             | **Urban Planning** Analyzing the intensity of commercial establishments across a city to inform zoning decisions.                          | **Retail Analysis** Examining the clustering of similar retail stores to understand competitive behavior and the impact on consumer choice.                             |
+-------------+--------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

This post is exploring the first-order to address the following questions -

1.  Are the childcare centres in Singapore randomly distributed throughout the country?
2.  Which location has higher concentration of childcare centres?

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## direction hints (credits to Uriel)

To address questions about the distribution of childcare centres in Singapore and identify areas with higher concentrations, both Kernel and Voronoi methods can be useful, but they offer different insights:

**Kernel Density Estimation (KDE)**

-   KDE would provide a smoothed representation of the distribution of childcare centres, highlighting areas of higher and lower density. It's particularly useful if you want to visualize a continuous surface of risk or probability density, which can be overlaid on a map to show hotspots where childcare centres are clustered.

-   KDE is advantageous when the question is about general trends and patterns in the data, such as identifying regions with notably high or low concentrations of centres.

**Voronoi Tessellation**

-   Voronoi tessellation would give you a more discrete map, partitioning the region into cells around each childcare centre. Each cell represents the area that is closest to a given centre compared to all others.

-   This method might be more useful if you're interested in understanding the specific area each centre is likely to serve or if you want to ensure that every point in the study area is accounted for without the smoothing that comes with KDE.

Having said all that, to address the questions above -

1.  To determine if childcare centres are randomly distributed, you could use KDE to see if there are discernable patterns or clusters. A purely random distribution would not show such patterns; it would be more uniform.
2.  To find which location has a higher concentration of childcare centres, KDE would typically be better because it can clearly highlight areas with higher densities of centres through the intensity of the color on the map.

In summary, KDE is generally better suited for these questions as it provides a visual representation of the density of childcare centres across the area, which directly helps to answer questions about randomness and concentration.

However, it's important to consider that KDE may introduce bias near the edges of the study region (edge effects), which is something that should be accounted for in the analysis.
:::

<br>

# **1. INITIAL**

## **1.1 Loading R Packages**

The following are the packages required for the hands-on exercise :

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## [**â‡³ Usage of the code chunk below :**]{style="color:#3a9c88"}

[***p_load( )*** - pacman -]{style="color:#d46e15"} to load packages into R environment. This function will attempt to install the package from CRAN or the pacman repository list if it is not installed.
:::

```{r}
pacman::p_load(maptools, sf, raster, spatstat, tmap, tidyverse)
```

<br>

## **1.2 Data Importation**

### 1.2.1 Import Geospatial Data

The data set for childcare centres are obtained from Data.gov.sg is a point feature data.

```{r}
childcare_sf <- st_read("data/geospatial/PreSchoolsLocation.geojson") %>%
  st_transform(crs = 3414)
```

```{r}
sg_sf <- st_read(dsn = "data/geospatial", 
                 layer = "CostalOutline")
```

```{r}
mpsz_sf = st_read(dsn = "data/geospatial",                                
                  layer = "MP14_SUBZONE_WEB_PL")
```

<br>

## 1.3 Data Inspection

```{r}
glimpse(childcare_sf, 70)
```

### 1.3.1 Reveal Projection System

::: panel-tabset
## Childcare Centres

```{r}
st_crs(childcare_sf)
```

## Singapore National Boundary

```{r}
st_crs(sg_sf)
```

## SGP Master Planning Subzone Boundary

```{r}
st_crs(mpsz_sf)
```
:::

<br>

## **1.4 Data Preprocessing :: Projection Transformation**

```{r}
sg_sf3414 <- st_transform(sg_sf, 
                          crs = 3414)
```

```{r}
mpsz_sf3414 <- st_transform(mpsz_sf, 
                            crs = 3414)
```

<br>

## **1.5 Data Visualisation**

NOTE : Interactive maps are more resource-intensive than static maps. Rendering many interactive maps in a single document can significantly increase the time it takes to knit the document and can cause performance issues such as slow to load or memory errors, especially if the document is viewed in a web browser. So, try to keep it below 10 usages within an RMarkdown.

```{r}
tmap_mode('view')
tm_shape(childcare_sf) +
  tm_dots(alpha = 0.5,
          size = 0.01) +
  tm_view(set.zoom.limits = c(11, 16))
```

```{r}
tmap_mode('plot')
```

<br>

# 2. DATA PROCESSING

## **2.1 Data Frame Conversion into `Spatial*`** Class

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## [**â‡³ Usage of the code chunk below :**]{style="color:#3a9c88"}

[[***as_Spatial( )***](https://www.rdocumentation.org/packages/sf/versions/0.3-0/topics/as_Spatial) - sf-]{style="color:#d46e15"} to convert simple feature, `sf`, data frame to `sp` object. Beware of the capital "S".
:::

```{r}
childcare <- as_Spatial(childcare_sf)
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial(sg_sf)
```

::: panel-tabset
## REVEAL : PLANNING ZONE

```{r}
mpsz
```

## NATIONAL BOUNDARY

```{r}
mpsz
```

## CHILDCARE

```{r}
childcare
```
:::

<br>

## **2.2 Data Frame Conversion with `sp`** Package

As one of the earliest packages for handling spatial data in R, the "sp" package provides classes for spatial data types that are prefixed with "Spatial", such as `SpatialPoints`, `SpatialPointsDataFrame`, `SpatialLines`, `SpatialPolygons`, `SpatialPolygonsDataFrame`, etc.

The main differences between `Spatial*` classes and the generic `sp` object:

**`Spatial*` Classes**

These classes are part of the "sp" package, which represents spatial data in R. They are S4 classes, which is a formal class system in R that allows for more rigorous data structure definition and method dispatch.

-   Each `Spatial*` class is tailored to specific types of spatial data & includes slots for metadata such as coordinate reference systems (CRS), bounding box, and attributes.
    -   `SpatialPoints` & `SpatialPointsDataFrame` handle point data
    -   `SpatialLines` & `SpatialLinesDataFrame` handle line data
    -   `SpatialPolygons` & `SpatialPolygonsDataFrame` handle polygon data.

**Generic `sp` Object**

The term "generic sp object" may refer to any `Spatial*` classes since they all inherit from the base `Spatial` class in the "sp" package.

### 2.2.1 Convert Spatial\* class into generic `sp` format

```{r}
childcare_sp <- as(childcare, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
```

<br>

### 2.2.2 Convert generic `sp` format into `spatstat`'s ppp format

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## [**â‡³ Usage of the code chunk below :**]{style="color:#3a9c88"}

[[***as_ppp( )***](https://www.rdocumentation.org/packages/spatstat/versions/1.64-1/topics/as.ppp) - spatstat -]{style="color:#d46e15"} to convert data into spatial point pattern. This is done so it can be used with spatstat package.
:::

```{r}
childcare_ppp <- as(childcare_sp, "ppp")
childcare_ppp
```

::: panel-tabset
## INSPECT DIFFERENCES

```{r}
plot(childcare_ppp)
```

## SUMMARY

```{r}
summary(childcare_ppp)
```

NOTE : Duplicated points may be due to points coinciding together.
:::

<br>

### 2.2.3 Manage Duplicated Points

#### 2.2.3.1 Verify any duplication

```{r}
any(duplicated(childcare_ppp))
```

```{r}
options(max.print = 5000)
```

NOTE : Set the `max.print` to above 2,290 if there is a warning message - "\[ reached getOption("max.print") - - omitted n entries \] when run the code chunk below.

```{r}
#| eval: false
multiplicity(childcare_ppp)
```

```{r}
sum(multiplicity(childcare_ppp) > 1)
```

#### 2.2.3.2 Visualise the duplication

```{r}
# create new object that captures each point multiplicity
childcare_multiplicity <- multiplicity(childcare_ppp)

# Convert the ppp object back to a `SpatialPoints` data frame
childcare_spdf <- as(childcare_ppp, "SpatialPoints")

# Add the multiplicity information to the `SpatialPoints` data frame
childcare_spdf$duplication <- childcare_multiplicity > 1

# Convert back to an sf object
childcare_test <- st_as_sf(childcare_spdf)

# Ensure the projection is correct.
childcare_test3414 <- st_set_crs(childcare_test, 3414)
```

```{r}
tm_shape(childcare_test3414) +
  tm_dots(col = "duplication", 
          palette = c("black", "red"), 
          size = 0.1,
          title = 'Duplication') +
  tm_layout(main.title = "DATA POINT DUPLICATIONS",
            main.title.size = 1.2)
```

#### 2.2.3.2 Overcome duplication

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## [**â‡³ Usage of the code chunk below :**]{style="color:#3a9c88"}

[***rjitter( )*** - spatstat -]{style="color:#d46e15"} to introduce independent random perturbation to each point in a point pattern.

-   `retry` when set to `TRUE` will perturb the point that lies outside the window of the original point pattern. Else, it will be lost.

-   `nsim` set the quantity of simulated realisation to be generated.

-   `drop` by default `TRUE` to produce point pattern. Else, a list containing point patterns.
:::

::: panel-tabset
## SOLUTION : JITTERING

```{r}
childcare_ppp_jit <- rjitter(childcare_ppp,
                             retry = TRUE, 
                             nsim = 1, 
                             drop = TRUE)
```

```{r}
rjitter(childcare_ppp,
        retry = TRUE,
        nsim = 2,
        drop = FALSE)
```

```{r}
any(duplicated(childcare_ppp_jit))
```

```{r}

childcare_ppp_jit0 <- multiplicity(childcare_ppp_jit)

# Convert the ppp object back to a `SpatialPoints` data frame
childcare_spdf0 <- as(childcare_ppp_jit, "SpatialPoints")

# Add the multiplicity information to the `SpatialPoints` data frame
childcare_spdf0$duplication <- childcare_ppp_jit0 > 1

# Convert back to an sf object
childcare_test0 <- st_as_sf(childcare_spdf0)

# Ensure the projection is correct.
childcare_test34140 <- st_set_crs(childcare_test0, 3414)
```

```{r}
tm_shape(childcare_test34140) +
  tm_dots(col = "duplication", 
          palette = c("black", "red"), 
          size = 0.1,
          title = 'Duplication') +
  tm_layout(main.title = "DATA POINT DUPLICATIONS",
            main.title.size = 1.2)
```
:::

<br>

## 2.3 Creating `owin` Object

`owin` short for "observation window". The region within this window where the spatial data (points, lines or polygons) are observed. The `owin` function is fundamental to define the spatial context for your point pattern analysis. It ensures that any spatial patterns or processes you are studying are constrained to a specific area of interest.

In the context of `spatstat` and point pattern analysis, this `window` can be interpreted as the outermost boundary or the extent of the study area for spatial data in other types of spatial analysis, such as `tm_shape()` from `tmap`. This extent defines the area over which the map is drawn and is determined by the bounding coordinates of the spatial object you are plotting.

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## [**â‡³ Usage of the code chunk below :**]{style="color:#3a9c88"}

[***owin( )*** - spatstat -]{style="color:#d46e15"} to create a window, i.e. Singapore land boundary.

-   NOTE : There are 2 ways to perform this function. Below code chunk is the alternative approach.
:::

```{r}
sg_owin <- as(sg_sp, "owin")
```

```{r}
#| fig-width: 6
#| fig-asp: 0.68
plot(sg_owin)
```

```{r}
summary(sg_owin)
```

<br>

## 2.4 Combining `owin` Object & Point Events Object

```{r}
childcareSG_ppp = childcare_ppp[sg_owin]
```

```{r}
summary(childcareSG_ppp)
```

```{r}
#| fig-width: 8
#| fig-asp: 0.68
plot(childcareSG_ppp)
```

<br>

# 3. FIRST-ORDER SPPA

This section will focus on computing the following -

-   Kernel Density Estimation (KDE) layer.

-   Confirmatory SPPA using Nearest Neighbour statistic.

## 3.1 Kernel Density Estimation

**KDE** is a non-parametric way (doesn't assume the childcare centres to follow any particular pattern or rule) to estimate the probability density function of points across the study area. This technique is useful to facilitate stakeholders to visualise the distribution of childcare centres across Singapore and identify areas of high & low concentrations.

*NOTE : For beginners who are confused - this statement "estimating the probability density" is a statistical way of talking about how likely you are to find a childcare centre if you were to look at a random spot in Singapore. KDE takes the actual locations of all the childcare centres to make an educated guess (estimate) of the likelihood (probability) or change of finding a centre in any given area.*

There are multiple approaches for KDE -

-   Automatic bandwidth selection method

### 3.1.1 Automatic bandwidth selection methods

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## [**â‡³ Usage of the code chunk below :**]{style="color:#3a9c88"}

[[***density( )***](https://www.rdocumentation.org/packages/spatstat.core/versions/2.3-1/topics/density.ppp) - spatstat -]{style="color:#d46e15"} to compute a kernel smoothed intensity function from a point pattern.

-   `Sigma` argument to adjust the level of smoothing with a single numerical value as the smoothing bandwidth. There are 4 functions, `bw.diggle`, `bw.CvL`, `bw.scott` or `bw.ppl` to perform automatic bandwidth using cross-validation. If this argument is not specified, the isotropic Gaussian kernel will be used to compute the sigma value.

    *NOTE : If any of you are struggling to grasp the concept of **Bandwidth (`sigma`)** - Think of the bandwidth as the width of the smoothing brush you use to pain the intensity of points on a map. A larger brush (bandwidth) paints over a larger area, smoothing out the details and showing a broader trend. A smaller brush reveals more local detail but can be noisier. (the metaphor credited to Uriel)*

-   `edge` to apply edge effect bias correction for the intensity estimation when `TRUE`. Default is `TRUE`.

-   `kernel` default value is "gaussian". Other options `epanechnikov`, `quartic` and `disc`.

    *NOTE : Again, credits to Uriel - The kernel is a function that defines the shape of the "brush" used to "paint" the intensity of the point pattern on the study area. It assigns weights to points within a certain region, with the weights typically decreasing with distance from the centre of the kernel.*

-   `scalekernel` default value is `TRUE` when the `kernel` is a character string instead of a pixel image. When it's true, the kernel shape is consistent across different bandwidths. This is useful when comparing KDE results across different bandwidths. Can consider `FALSE` when intended to explore how the bandwidth can alter the shape of kernel.
:::

::: panel-tabset
## SIGMA : bw.diggle

This method uses the average distance between points and the total area of the study region to determine an appropriate bandwidth.

```{r}
kde_childcareSG_bw <- density(childcareSG_ppp,
                              sigma = bw.diggle,
                              edge = TRUE,
                              kernel = "gaussian")
plot(kde_childcareSG_bw)
```

```{r}
bw.diggle(childcareSG_ppp)
```

## bw.scott

This option is useful for estimating gradual trend as it produces a larger bandwidth than diggle.

According to the Scott's rule : the bandwidth is proportional to n^-1/(d+4)^ where,

-   n = the number of points

    -   Having more points means smaller bandwidth will be - have more information, thus can afford to look at finer details.

-   d = the number of spatial dimensions, typically 2 for a map (x & y dimensions).

    -   Having more dimensions means larger the bandwidth will be.

*NOTE : `bw.scott` has an option to use isotropic bandwidth. When `isotropic` = `TRUE`, use same bandwidth in all directions. If `FALSE` (default), calculate different bandwidths for different directions. The latter is useful when the points distribution is different in the x and y directions.*

```{r}
#isotropic is FALSE(default)
kde_childcareSG_bwsct <- density(childcareSG_ppp,
                                 sigma = bw.scott,
                                 edge = TRUE,
                                 kernel = "gaussian")
plot(kde_childcareSG_bwsct)
```

```{r}
bw.scott(childcareSG_ppp)
```

```{r}
#isotropic set to TRUE, the differences are observed btw these 2 plots.
kde_childcareSG_bwsctf <- density(childcareSG_ppp,
                                 sigma = bw.scott(childcareSG_ppp, 
                                                  isotropic = TRUE),
                                 edge = TRUE,
                                 kernel = "gaussian")
plot(kde_childcareSG_bwsctf)
```

```{r}
bw.scott(childcareSG_ppp, isotropic = TRUE)
```

## bw.CvL

Uses Cronie & van Lieshout's Criterion to select the smoothing bandwidth.

CvL(Ïƒ) = ( \|W\| - Sum \[ 1 / Î»Ì‚ (x~i~) \] )^2^

The goal is to find the bandwidth Ïƒ that minimise the discrepancy between the area of the observation window and the sum of reciprocal estimated intensity.

-   This is done by identifying the balance where the estimated density is neither too wiggly (overfitting to the data points) nor too smooth (underfitting and missing important features).

-   The bandwidth that gives the lowest value of the criterion is chosen as the best one.

-   Meaning, according to cross-validation likelihood, the selected bandwidth will provide the most reliable density estimate that perform well both in representing the high-density areas (where points are clustered) and avoiding to be mislead by random fluctuations or noise in the spatial distribution of the childcare centres.

```{r}
kde_childcareSG_bwcvl <- density(childcareSG_ppp,
                                 sigma = bw.CvL,
                                 edge = TRUE,
                                 kernel = "gaussian")
plot(kde_childcareSG_bwcvl)
```

```{r}
bw.CvL(childcareSG_ppp)
```

## bw.frac

This option is an quantile-based bandwidth. The Ïƒ is selected such that a certain percentage (quantile) of all pairwise distances between independent random points is below it.

By default, it uses the lower quartile, i.e. the bandwidth smaller than 25% of all pairwise distances. This allows it to focus on the denser core areas of distribution, providing a clear visualisation of where childcare services are most concentrated.

```{r}
kde_childcareSG_bwfra <- density(childcareSG_ppp,
                              sigma = bw.frac,
                              edge = FALSE,
                              kernel = "gaussian")
plot(kde_childcareSG_bwfra)
```

```{r}
bw.frac(childcareSG_ppp)
```

## bw.ppl

ppl shorts for "plug-in predictor", estimates the bandwidth that would minimise the mean squared error of the density estimate. Compared to `bw.diggle`, `bw.ppl` can be more accurate but computationally more intensive.

```{r}
kde_childcareSG_bwppl <- density(childcareSG_ppp,
                              sigma = bw.ppl,
                              edge = FALSE,
                              kernel = "gaussian")
plot(kde_childcareSG_bwppl)
```

```{r}
bw.ppl(childcareSG_ppp)
```
:::

### 3.1.2 Rescaling KDE value

Default unit for svy21 is in meter. Hence, the computed density values above are in n points per square meter (the colour bar legend on the right).

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## [**â‡³ Usage of the code chunk below :**]{style="color:#3a9c88"}

[***rescale( )*** - spatstat -]{style="color:#d46e15"} to convert the *`childcareSG_ppp`* from meter to kilometer.
:::

```{r}
childcareSG_ppp.km <- rescale(childcareSG_ppp, 1000, "km")
```

::: panel-tabset
## SIGMA : bw.diggle

```{r}
kde_childcareSG_bwdig <- density(childcareSG_ppp.km,
                              sigma = bw.diggle,
                              edge = TRUE,                  
                              kernel = "gaussian") 
plot(kde_childcareSG_bwdig)
```

```{r}
bw.diggle(childcareSG_ppp.km)
```

## bw.scott

```{r}
#isotropic is FALSE(default) 
kde_childcareSG_bwsct <- density(childcareSG_ppp.km,                       
                                 sigma = bw.scott,                        
                                 edge = TRUE,                           
                                 kernel = "gaussian") 
plot(kde_childcareSG_bwsct)
```

```{r}
#isotropic set to TRUE, the differences are observed btw these 2 plots. 
kde_childcareSG_bwsctf <- density(childcareSG_ppp.km,                         
                                  sigma = bw.scott(childcareSG_ppp,            
                                                   isotropic = TRUE),         
                                  edge = TRUE,                                
                                  kernel = "gaussian") 
plot(kde_childcareSG_bwsctf)
```

## bw.CvL

```{r}
kde_childcareSG_bwcvl <- density(childcareSG_ppp.km,                          
                                 sigma = bw.CvL,                          
                                 edge = TRUE,                           
                                 kernel = "gaussian") 
plot(kde_childcareSG_bwcvl)
```

## bw.frac

```{r}
kde_childcareSG_bwfra <- density(childcareSG_ppp.km,                         
                                 sigma = bw.frac,                             
                                 edge = FALSE,                          
                                 kernel = "gaussian") 
plot(kde_childcareSG_bwfra)
```

## bw.ppl

```{r}
kde_childcareSG_bwppl <- density(childcareSG_ppp.km,                        
                                 sigma = bw.ppl,                               
                                 edge = FALSE,                               
                                 kernel = "gaussian") 
plot(kde_childcareSG_bwppl)
```
:::

After comparing the outputs from these options, for the context of this post, that is, the distribution of childcare centres, one may want to consider using -

-   `bw.ppl` option can produce more appropriate values when the pattern consists predominantly of tight clusters.

-   `bw.diggle` option is more suitable when the goal is to detect a single tight cluster among random noise.

```{r}
plot(kde_childcareSG_bwdig, main = "bw.diggle")
plot(kde_childcareSG_bwppl, main = "bw.ppl")
```

### 3.1.3 Different Kernel Methods

NOTE :

-   If `scalekernel` set to `TRUE`, the KDE map for childcare centres will be more uniform / standardised view and smoother variations in density.

-   If `FALSE`, may be able to highlight local clusters or gaps more distinctly, but also making the results more sensitive to the choice of bandwidth.

::: panel-tabset
## KERNEL : GAUSSIAN

This assigns weights to points based on the Gaussian (normal) distribution. It gives higher weights to points closer to the centre of the kernel and gradually less to points further away, without ever reaching zero.

USE CASES (credits to Uriel) :

-   Without prior knowledge about the distribution of points and want a smooth, infinitely differentiable estimate.

-   For environmental data analysis, especially modelling pollution dispersion which follows a gradient descent similar to a Gaussian distribution.

```{r}
plot(density(childcareSG_ppp.km, 
             sigma = bw.ppl, 
             edge = TRUE, 
             kernel = "gaussian"), 
     main = "Gaussian")
```

## EPANECHNIKOV

This kernel is parabolic and has a finite support. It only assign weights to points within a certain distance. Though, it is more computationally efficient than the Gaussian kernel.

USE CASES :

-   When study area is large and intended to ignore very distant points.

-   Estimate animal home ranges in wildlife studies. Except for certain wild beings like sea turtle or salmon, observations far from centre are less likely to influence the home range estimate.

```{r}
plot(density(childcareSG_ppp.km, 
             sigma = bw.ppl, 
             edge = TRUE, 
             kernel = "epanechnikov"), 
     main = "Epanechnikov")
```

## QUARTIC

This kernel option is similar to Epanechnikov kernel, has finite support, but uses a biweight algorithm that offering bell-shaped weighting.

USE CASES :

-   When require properties of Gaussian's smooth estimate and Epanechnikov's finite support property.

-   For crime analysis that focus on hotspots but still consider a tapering effect for incidents that occur near the edge of these hotspots.

```{r}
plot(density(childcareSG_ppp.km, 
             sigma = bw.ppl, 
             edge = TRUE, 
             kernel = "quartic"), 
     main = "Quartic")
```

## DISC

This option assign equal weight to all points within a certain radius and zero weight to points outside. This is the simplest form of kernel with a hard cut-off.

USE CASES :

-   Model phenomena with a uniform influence within a set distance, such as the coverage area of a cell tower.

-   Evaluate the catchment area of store, in retail analysis, where all customers within a certain radius are considered equally likely to visit.

```{r}
plot(density(childcareSG_ppp.km, 
             sigma = bw.ppl, 
             edge = TRUE, 
             kernel = "disc"), 
     main = "Disc")
```
:::

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## [**â‡³ Usage of the code chunk below :**]{style="color:#3a9c88"}

[[***mfrow( )***](https://bookdown.org/ndphillips/YaRrr/arranging-plots-with-parmfrow-and-layout.html) - RcmdrPlugin -]{style="color:#d46e15"} to create a matrix layout for `plot` array.
:::

```{r}
par(mfrow = c(2,2))
plot(density(childcareSG_ppp.km, 
             sigma = bw.ppl, 
             edge = TRUE, 
             kernel = "gaussian"), 
     main = "Gaussian")

plot(density(childcareSG_ppp.km, 
             sigma = bw.ppl, 
             edge = TRUE, 
             kernel = "epanechnikov"), 
     main = "Epanechnikov")

plot(density(childcareSG_ppp.km, 
             sigma = bw.ppl, 
             edge = TRUE, 
             kernel = "quartic"), 
     main = "Quartic")

plot(density(childcareSG_ppp.km, 
             sigma = bw.ppl, 
             edge = TRUE, 
             kernel = "disc"), 
     main = "Disc")
```

### 3.1.4 Fixed Bandwidth vs. Adaptive Bandwidth

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## [**â‡³ Usage of the code chunk below :**]{style="color:#3a9c88"}

[***adaptive.density( )*** - spatstat -]{style="color:#d46e15"} to computes an adaptive estimation.

-   `method` is set to `voronoi`, the data will be parsed under `densityVoronoi` which estimate intensity based on Voronoi Dirichlet tessellation.
:::

::: panel-tabset
## FIXED BANDWIDTH

The following attempt will be using 500 meter, i.e. sigma = 0.5 since *`childcareSG_ppp.km`* is in kilometer.

```{r}
kde_childcareSG_500 <- density(childcareSG_ppp.km, 
                               sigma = 0.5, 
                               edge = TRUE, 
                               kernel = "gaussian")
plot(kde_childcareSG_500, 
     main = "Fixed Bandwidth : 500 meter")
```

## ADAPTIVE BANDWIDTH

Unlike fixed bandwidth, this approach has lower sensitive towards highly skewed distribution of spatial point patterns over geographical units.

**Kernel Method**

The adaptive kernel allows the bandwidth to vary with the local density of points, meaning it can adapt to the underlying structure of the point pattern.

USE CASES :

-   Visualise crime hotspots in a city where areas with high crime rates are smoothed differently from low-rate areas, providing a detailed intensity map.

-   Identify clusters of high disease prevalence in mapping disease incidence rates. The smoothing adjusted for areas with varying case numbers.

```{r}
kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, 
                                             method = "kernel")
plot(kde_childcareSG_adaptive,
     main = "Adaptive : Kernel Method")
```

**Voronoi Method**

As shown in the plot below, this approach partitioned the study area into regions around each point. The intensity estimate at any location is inversely proportional to the area of the Voronoi cell that contains the location.

USE CASES :

-   Estimate animal territories or home ranges in ecological studies where each point represents an animal sighting. This method can give an estimate of the area dominated by each sighting.

-   Estimate the influence area of public facilities like parks or libraries in urban planning, where each facility is expected to serve the nearest neighbourhood.

```{r}
kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, 
                                             method = "voronoi")
plot(kde_childcareSG_adaptive,
     main = "Adaptive : Voronoi Method")
```

NOTE : The key difference between the 2 methods - how they approach the estimation of intensity. The voronoi output tend to be more discrete and polygon-based while the kernel output is more continuous and smooth (based on local point density).
:::

### 3.1.5 Convert KDE output into grid object

#### 3.1.5.1 Convert into gridded kernal density object

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## [**â‡³ Usage of the code chunk below :**]{style="color:#3a9c88"}

[[***SpatialGridDataFrame( )***](https://www.rdocumentation.org/packages/sp/versions/2.1-1/topics/image.SpatialGridDataFrame) - sp -]{style="color:#d46e15"} to convert into gridded data structure.
:::

```{r}
gridded_kde_childcareSG_bw <- as.SpatialGridDataFrame.im(kde_childcareSG_bwdig)
```

```{r}
spplot(gridded_kde_childcareSG_bw)
```

#### 3.1.5.2 Convert gridded kernal density object into RasterLayer object

```{r}
kde_childcareSG_bw_raster <- raster(gridded_kde_childcareSG_bw)
```

```{r}
kde_childcareSG_bw_raster
```

#### 3.1.5.3 Assign CRS to RasterLayer object

```{r}
projection(kde_childcareSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_childcareSG_bw_raster
```

#### 3.1.5.4 Visualise RasterLayer object

```{r}
tm_shape(kde_childcareSG_bw_raster) + 
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), 
            frame = FALSE)
```

<br>

::: panel-tabset
## Comparing Spatial Point Patterns using KDE

Step 1 - Extracting study area

```{r}
pg = mpsz[mpsz@data$PLN_AREA_N == "PUNGGOL",]
tm = mpsz[mpsz@data$PLN_AREA_N == "TAMPINES",]
ck = mpsz[mpsz@data$PLN_AREA_N == "CHOA CHU KANG",]
jw = mpsz[mpsz@data$PLN_AREA_N == "JURONG WEST",]
```

Step 2 - Plotting target planning areas

```{r}
par(mfrow=c(2,2)) 
plot(pg, main = "Ponggol") 
plot(tm, main = "Tampines") 
plot(ck, main = "Choa Chu Kang") 
plot(jw, main = "Jurong West")
```

Step 3 - Converting the spatial point data frame into generic sp format

```{r}
pg_sp = as(pg, "SpatialPolygons") 
tm_sp = as(tm, "SpatialPolygons") 
ck_sp = as(ck, "SpatialPolygons") 
jw_sp = as(jw, "SpatialPolygons")
```

Step 4 - Creating `owin` object

```{r}
pg_owin = as(pg_sp, "owin") 
tm_owin = as(tm_sp, "owin") 
ck_owin = as(ck_sp, "owin") 
jw_owin = as(jw_sp, "owin")
```

Step 5 - Combining childcare points and the study area

```{r}
childcare_pg_ppp = childcare_ppp_jit[pg_owin] 
childcare_tm_ppp = childcare_ppp_jit[tm_owin] 
childcare_ck_ppp = childcare_ppp_jit[ck_owin] 
childcare_jw_ppp = childcare_ppp_jit[jw_owin]
```

Step 6 - Rescale the data

```{r}
childcare_pg_ppp.km = rescale(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale(childcare_jw_ppp, 1000, "km")
```

Step 7 - Visualise

```{r}
par(mfrow = c(2,2))
plot(childcare_pg_ppp.km, main = "Punggol")
plot(childcare_tm_ppp.km, main = "Tampines")
plot(childcare_ck_ppp.km, main = "Choa Chu Kang")
plot(childcare_jw_ppp.km, main = "Jurong West")
```

Step 8 - Compute KDE

```{r}
par(mfrow = c(2,2))
plot(density(childcare_pg_ppp.km, 
             sigma = bw.diggle, 
             edge = TRUE, 
             kernel = "gaussian"),
     main = "Punggol")

plot(density(childcare_tm_ppp.km, 
             sigma = bw.diggle, 
             edge = TRUE, 
             kernel = "gaussian"),
     main = "Tempines")

plot(density(childcare_ck_ppp.km, 
             sigma = bw.diggle, 
             edge = TRUE, 
             kernel = "gaussian"),
     main = "Choa Chu Kang")

plot(density(childcare_jw_ppp.km, 
             sigma = bw.diggle, 
             edge = TRUE, 
             kernel = "gaussian"),
     main = "JUrong West")
```

Step 9 - Compute fixed bandwidth KDE

```{r}
par(mfrow = c(2,2))
plot(density(childcare_ck_ppp.km, 
             sigma = 0.25, 
             edge = TRUE, 
             kernel = "gaussian"),
     main = "Chou Chu Kang")

plot(density(childcare_jw_ppp.km, 
             sigma = 0.25, 
             edge = TRUE, 
             kernel = "gaussian"),
     main = "JUrong West")

plot(density(childcare_pg_ppp.km, 
             sigma = 0.25, 
             edge = TRUE, 
             kernel = "gaussian"),
     main = "Punggol")

plot(density(childcare_tm_ppp.km, 
             sigma = 0.25, 
             edge = TRUE, 
             kernel = "gaussian"),
     main = "Tampines")
```
:::

::: panel-tabset
## TAB1 : TEMPLATE

## TAB2
:::
